#  반복문

while (조건){
    반복해서 실행할 코드
}


while (true) {
    console.log("Hello MisterHaru!");
}


while (true) {
    document.write("Hello MisterHaru! <br />" );
}

#  while 문
var i = 1;

while(i < 10) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
    i++
}

#  for 문

for(var i = 1; i < 16; i++) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
}

var ID = misterharu;
alert(prompt("아이디를 입력하세요!"));
if(misterharu){"안녕하세요!" + ID +"님."
} else alert("아이디 입력이 틀렸습니다.");

for(var i = 1; i < 16; i++) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
}



#  break & continue 문

for(var i = 0; i < 10; i++){
    if(i === 5) {
        break;
    }
    document.write('coding everybody'+i+'<br />');
}




for(var i = 0; i < 10; i++){
    if(i === 5) {
        continue;
    }
    document.write('coding everybody'+i+'<br />');
}



# 함수의 형식
function 함수명( [인자...[,인자]] ){
    코드
    return 반환값
}


# 객체(Object)
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};


// RegExr expression - 치환
var pattern = /(\w+)\satisfies(\w+)/;
var str = "conding everybody";
var result = str.replace(pattern, "$2, $1");
console.log(result);

var urlPattern = /\b(?:https?):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*/gim;
var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';
var result = content.replace(urlPattern, function(url){
    return '<a href="'+url+'">'+url+'</a>';
});
console.log(result);
\


//전역변수의 사용
MYAPP = {}
MYAPP.calculator = {
    'left' : null,
    'right' : null
}
MYAPP.coordinate = {
    'left' : null,
    'right' : null
}
 
MYAPP.calculator.left = 10;
MYAPP.calculator.right = 20;
function sum(){
    return MYAPP.calculator.left + MYAPP.calculator.right;
}
document.write(sum());


//전역 변수를 지역 변수로 변경
(function(){
    var MYAPP = {}
    MYAPP.calculator = {
        'left' : null,
        'right' : null
    }
    MYAPP.coordinate = {
        'left' : null,
        'right' : null
    }
    MYAPP.calculator.left = 10;
    MYAPP.calculator.right = 20;
    function sum(){
        return MYAPP.calculator.left + MYAPP.calculator.right;
    }
    document.write(sum());
}())



//함수는 함수의 리턴 값으로도 사용할 수 있다.
function cal(mode){
    var funcs = {
        'plus' : function(left, right){return left + right},
        'minus' : function(left, right){return left - right}
    }
    return funcs[mode];
}
alert(cal('plus')(2,1));
alert(cal('minus')(2,1));   


//당연히 배열의 값으로도 사용할 수 있다.
var process = [
    function(input){ return input + 10;},
    function(input){ return input * input;},
    function(input){ return input / 2;}
];
var input = 1;
for(var i = 0; i < process.length; i++){
    input = process[i](input);
}
alert(input);



# 처리의 위임
//값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.

function sortNumber(a,b){
    // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
    return b-a;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]


// 클랜 획득 점수에 따른 리더보드 순위와 구분을 할 수 있다.

var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
var sortfunc = function(a, b){
    return b - a;
}
console.log(numbers.sort(sortfunc));


# 비동기 처리
<!DOCTYPE html>
<html>
<head>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
</head>
<body>
<script type="text/javascript">
    $.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
</script>
</body>
</html>



# 클로저
function outter(){
    var title = 'coding everybody';  
    return function(){        
        alert(title);
    }
}
inner = outter();
inner();


//

function factory_movie(title){
    return {
        get_title : function (){
            return title;
        },
        set_title : function(_title){
            if(typeof _title === 'String'){
                title = _title
            } else {
                alert('제목은 문자열이어야 합니다.');
            }
            
        }
    }
}
ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');
 
alert(ghost.get_title());
alert(matrix.get_title());
 
ghost.set_title('공각기동대');
 
alert(ghost.get_title());
alert(matrix.get_title());



//
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}



# arguments

function sum(){
    var i, _sum = 0;    
    for(i = 0; i < arguments.length; i++){
        document.write(i+' : '+arguments[i]+'<br />');
        _sum += arguments[i];
    }   
    return _sum;
}
document.write('result : ' + sum(1,2,3,4));



//
function zero(){
    console.log(
        'zero.length', zero.length,
        'arguments', arguments.length
    );
}
function one(arg1){
    console.log(
        'one.length', one.length,
        'arguments', arguments.length
    );
}
function two(arg1, arg2){
    console.log(
        'two.length', two.length,
        'arguments', arguments.length
    );
}
zero(); // zero.length 0 arguments 0 
one('val1', 'val2');  // one.length 1 arguments 2 
two('val1');  // two.length 2 arguments 1



//
function sum(arg1, arg2){
    return arg1+arg2;
}
alert(sum.apply(null, [1,2]))


# apply

sum.apply(null, [1.2]);


//
o1 = {val1:1, val2:2, val3:3}
o2 = {v1:10, v2:50, v3:100, v4:25}
function sum(){
    var _sum = 0;
    for(name in this){
        _sum += this[name];
    }
    return _sum;
}
alert(sum.apply(o1)) // 6
alert(sum.apply(o2)) // 185


//
var preson = {}
preson.name = 'egoing';
preson.introduce = function(){
    return 'My name is'+this.name;
}
document.write(preson.introduce());



//생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다.
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");

var p2 = new Person('leezche');
document.write(p2.introduce());


// apply call 을 이용해서 this의 값을 제어
var o = {}
var p = {}
function func(){
    switch(this){
        case o:
            document.write('o<br />');
            break;
        case p:
            document.write('p<br />');
            break;
        case window:
            document.write('window<br />');
            break;          
    }
}
func();
func.apply(o);
func.apply(p);

# 상속(inheritance)
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");


// 수정
function Person(name){
    this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
    return 'My name is '+this.name; 
}

function Programmer(name){
    this.name = name;
}
Programmer.prototype = new Person();
Programmer.prototype.coding = function(){
    return "hello world";
}

function Designer(name){
    this.name = name;
}
Designer.prototype = new Person();
Designer.prototype.design = function(){
    return "beautiful!";
}

var p1 = new Programmer('egoing');
document.write(p1.introduce()+"<br />");
document.write(p1.coding()+"<br />");

var p2 = new Designer('Haru');
document.write(p2.introduce()+"<br />");
document.write(p2.design()+"<br />");


# prototype
Array.prototype.rand = function(){
    var index = Math.floor(this.length*Math.random());
    return this[index];
}
var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');
console.log(arr.rand());


#  Object
Object.prototype.contain = function(neddle) {
    for(var name in this){
        if(this[name] === neddle){
            return true;
        }
    }
    return false;
}
var o = {'name':'egoing', 'city':'seoul'}
console.log(o.contain('egoing'));
var a = ['egoing','leezche','grapittie'];
console.log(a.contain('leezche'));
//
for(var name in o){
    if(o.hasOwnProperty(name))
        console.log(name);  
}

// 입력연습
Object.prototype.contain = function(MisterHaru){
    for(var name in this){
        if(this[name] === MisterHaru){
            return true;
        }
    }
}


#  hasOwnProperty 에 대해 추가 공부 필요

//Wrapper Object 레퍼 객체 , 원시 데이터 타입
// var str = 'coding';
// str = new String('coding');

var str = 'coding';
console.log(str.length);        // 6
console.log(str.charAt(0));     // "C"

var str = 'coding';
str.prop = 'everybody';
console.log(str.prop);      // undefined


// 밤 낮 화이트 블랙 변경
<input type="button" value="night" onclick="
    document.querySelector('body').style.backgroundColor='black;
    document.querySelector('body').style.color='white';
">
<input type="button" value="day" onclick="
    document.querySelector('body').style.backgroundColor='white;
    document.querySelector('body').style.color='black';
">

//
<input type="button" value="hi" onclick="alert('hi')">
<input type="text" onchange="alert('changed')">
<input type="text" onkeydown="alert('key down!')">



/////////////


요약
문자열에서 인자로 주어진 값에 해당하는 문자를 리턴한다.

문법
# charAt(index)
인자
index - 필수, 0보다 큰 정수

설명
문자열에 속하는 문자는 왼쪽부터 오른쪽까지 0부터 인덱싱되어 있다.
charAt은 index로 주어진 값에 해당하는 문자를 리턴한다.
인덱스는 0부터 시작하기 때문에 index로 들어갈 수 있는 가장 큰 수는 (문자열.legnth-1)이다.
존재하지 않는 index를 인자로 전달하면 공백이 출력된다.
charAt 는 index에 해당하는 문자를 리턴하고, chartCodeAt은 유니코드 값을 리턴하는 차이가 있다.

예제
var stringName = 'coding everybody';
alert(stringName.charAt(0)); // c
alert(stringName.charAt(stringName.length-1)); // y
alert(stringName.charAt(1000) == ''); // true



#  charCodeAt
요약
index에 해당하는 문자의 unicode 값을 리턴

문법
string.charCodeAt(index)
인자
index - 필수, 0보다 큰 정수

설명
유니코드는 모든 시스템에서 일관되게 문자를 표현하기 위한 산업표준이다.
charCodeAt은 주어진 index에 해당하는 유니코드 값을 리턴하는데 이 값은 unicode가 지원되는 모든 시스템에서 동일한 문자를 가르킨다.
charAt 는 index에 해당하는 문자를 리턴하고, chartCodeAt은 유니코드 값을 리턴하는 차이가 있다.

예제
var stringName = '생활코딩'
alert(stringName.charCodeAt(0)); // 493373 
// http://www.unicode.org/charts/PDF/UAC00.pdf 에서 '생'을 찾아보면 'C0DD'인데 이것은 16진수다. 
// 이를 10진수로 변환하면 493373이 된다

395로5168

# 웹브라우저와 javascript

JavaScript
HTML을 프로그래밍적으로 제어한다. 


<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
        #selected{
            color:red;
        }
        .dark {
            background-color:black;
            color:white;
        }
        .dark #selected{
            color:yellow;
        }
    </style>
</head>
<body>
    <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li id="selected">JavaScript</li>
    </ul>
    <input type="button" onclick="document.body.className='dark'" value="dark" />
</body>
</html>



//
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
    <input type="button" id="hw" value="hello world">
    <script type="text/javascript">
        var hw = document.getElementById('hw');
        hw.addEventListener('click', function(){
            alert('Hello world');
        })
    </script>
</body>
</html>




///

<!DOCTYPE html>
<html>
<body>
    <input type="button" id="hw" value="Hello world" />
    <script type="text/javascript" src="script2.js"></script>
</body>
</html>


* script2.js
var hw = document.getElementById('hw');
hw.addEventListener('click', function(){
    alert('Hello world');
})




window.onload = function(){
    var hw = document.getElementById('hw');
    hw.addEventListener('click', function(){
        alert('Hello world');
    })
}
//window.onload = function(){} 
//html 모두를 웹브라우저에 실행후 마지막에 호출



# 전역객체
<!document html>
<html>
<script>
    alert('Hell world');
    window.alert('Hello World');
</script>
<body>
</body>
</html>

// Location 객체

// URL Parsing
console.log(location.protocol, location.host, location.port, location.pathname, location.search, location.hash)


//현재 문서를 http://egoing.net으로 이동한다.
location.href = 'http://egoing.net';
location = 'http://egoing.net';

# 리로드
location.href=location.href
location.reload();


# Navigator 객체
객체의 모든 프로퍼티를 열람할 수 있다.
console.dir(navigator);
console.dir(navigator.appName);
console.dir(navigator.appVersion);
console.dir(navigator.userAgent);
console.dir(navigator.platform);



//Object.keys라는 메소드는 객체의 key 값을 배열로 리턴하는 Object의 메소드다. 이 메소드는 ECMAScript5에 추가되었기 때문에 오래된 자바스크립트와는 호환되지 않는다. 아래의 코드를 통해서 호환성을 맞출 수 있다. 

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
    if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
    }

    var result = [], prop, i;

    for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
        result.push(prop);
        }
    }

    if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
        if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
        }
        }
    }
    return result;
    };
}());
}


//
<!DOCTYPE html>
<html>
<style>li {padding:10px; list-style: none}</style>
<body>
<ul>
    <li>
        첫번째 인자는 새 창에 로드할 문서의 URL이다. 인자를 생략하면 이름이 붙지 않은 새 창이 만들어진다.<br />
        <input type="button" onclick="open1()" value="window.open('demo2.html');" />
    </li>
    <li>
        두번째 인자는 새 창의 이름이다. _self는 스크립트가 실행되는 창을 의미한다.<br />
        <input type="button" onclick="open2()" value="window.open('demo2.html', '_self');" />
    </li>
    <li>
        _blank는 새 창을 의미한다. <br />
        <input type="button" onclick="open3()" value="window.open('demo2.html', '_blank');" />
    </li>
    <li>
        창에 이름을 붙일 수 있다. open을 재실행 했을 때 동일한 이름의 창이 있다면 그곳으로 문서가 로드된다.<br />
        <input type="button" onclick="open4()" value="window.open('demo2.html', 'ot');" />
    </li>
    <li>
        세번재 인자는 새 창의 모양과 관련된 속성이 온다.<br />
        <input type="button" onclick="open5()" value="window.open('demo2.html', '_blank', 'width=200, height=200, resizable=yes');" />
    </li>
</ul>
 
<script>
function open1(){
    window.open('demo2.html');
}
function open2(){
    window.open('demo2.html', '_self');
}
function open3(){
    window.open('demo2.html', '_blank');
}
function open4(){
    window.open('demo2.html', 'ot');
}
function open5(){
    window.open('demo2.html', '_blank', 'width=200, height=200, resizable=no');
}
</script>
</body>
</html>


//제어 대상을 찾기
document.getElementsByTagName
document.getElementsByClassName
document.getElementById
document.querySelector 
document.querySelectorAll




# document.getElementsByTagName
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<script>
    var ul = document.getElementsByTagName('ul')[0];
    var lis = ul.getElementsByTagName('li');
    for(var i=0; lis.length; i++){
        lis[i].style.color='red';   
    }
</script>


# document.getElementsByClassName
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li class="active">JavaScript</li>
</ul>
<script>
    var lis = document.getElementsByClassName('active');
    for(var i=0; i < lis.length; i++){
        lis[i].style.color='red';   
    }
</script>
</body>
</html>


# document.getElementById
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li id="active">CSS</li>
    <li>JavaScript</li>
</ul>
<script>
    var li = document.getElementById('active');
    li.style.color='red';
</script>
</body>
</html>


# document.querySelector
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<ol>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li>JavaScript</li>
</ol>
 
<script>
    var li = document.querySelector('li');
    li.style.color='red';
    var li = document.querySelector('.active');
    li.style.color='blue';
</script>
</body>
</html>


//document.querySelectorAll
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<ol>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li>JavaScript</li>
</ol>

<script>
    var lis = document.querySelectorAll('li');
    for(var name in lis){
        lis[name].style.color = 'blue';
    }
</script>
</body>
</html>



#  jQuery

$ = jQuery function
$('li').css('color','red');
는 <li style="color:red"> 이다.

<!DOCTYPE html>
<html>
<head>
    <style>
    #demo{width:200px;float: left; margin-top:120px;}
    #execute{float: left; margin:0; font-size:0.9em;}
    #execute{padding-left: 5px}
    #execute li{list-style: none}
    #execute pre{border:1px solid gray; padding:10px;}
    </style>
</head>
<body>
<ul id="demo">
    <li class="active">HTML</li>
    <li id="active">CSS</li>
    <li class="active">JavaScript</li>
</ul>
<ul id="execute">
    <li>
        <pre>
var lis = document.getElementsByTagName('li');
for(var i=0; i&lt;lis.length; i++){
    lis[i].style.color='red';   
</pre>
        <pre>
$('li').css('color', 'red')     </pre>
        <input type="button" value="execute" onclick="$('li').css('color', 'red')" />
    </li>
    <li>
        <pre>
var lis = document.getElementsByClassName('active');
for(var i=0; i &lt; lis.length; i++){
    lis[i].style.color='red';   
}</pre>
        <pre>
$('.active').css('color', 'red')</pre>
        <input type="button" value="execute" onclick="$('.active').css('color', 'red')" />
    </li>
    <li>
        <pre>
var li = document.getElementById('active');
li.style.color='red';
li.style.textDecoration='underline';</pre>
        <pre>
$('$active').css('color', 'red').css('textDecoration', 'underline');
        </pre>
        <input type="button" value="execute" onclick="$('#active').css('color', 'red').css('textDecoration', 'underline')" />
    </li>
</ul>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
</body>
</html>


#  HTMLElement

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="active">JavaScript</li>
</ul>
<script>
    var li = document.getElementById('active');
    console.log(li.constructor.name);
    var lis = document.getElementsByTagName('li');
    console.log(lis.constructor.name);
</script>

document.getElementById : 리턴 데이터 타입은 HTMLLIELement
document.getElementsByTagName : 리턴 데이터 타입은 HTMLCollection

실행결과가 하나인 경우 HTMLLIELement, 복수인 경우 HTMLCollection을 리턴하고 있다. 


# HTMLELement
<a id="anchor" href="http://opentutorials.org">opentutorials</a>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="list">JavaScript</li>
</ul>
<input type="button" id="button" value="button" />
<script>
    var target = document.getElementById('list');
    console.log(target.constructor.name);

    var target = document.getElementById('anchor');
    console.log(target.constructor.name);

    var target = document.getElementById('button');
    console.log(target.constructor.name);
</script>


interface HTMLLIElement : HTMLElement {
           attribute DOMString       type;
           attribute long            value;
};


다음은 HTMLAnchroElement이다.

interface HTMLAnchorElement : HTMLElement {
           attribute DOMString       accessKey;
           attribute DOMString       charset;
           attribute DOMString       coords;
           attribute DOMString       href;
           attribute DOMString       hreflang;
           attribute DOMString       name;
           attribute DOMString       rel;
           attribute DOMString       rev;
           attribute DOMString       shape;
           attribute long            tabIndex;
           attribute DOMString       target;
           attribute DOMString       type;
  void               blur();
  void               focus();
};




target.href = 'http://misterharu.com';


# HTMLCollection

<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="active">JavaScript</li>
</ul>
<script>
console.group('before');
var lis = document.getElementsByTagName('li');
for(var i = 0; i < lis.length; i++){
    console.log(lis[i]);
}
console.groupEnd();
console.group('after');
lis[1].parentNode.removeChild(lis[1]);
for(var i = 0; i < lis.length; i++){
    console.log(lis[i]);
}
console.groupEnd();
</script>
</body>
</html>



# jQuery 

<ul>
    <li>html</li>
    <li>css</li>
    <li>JavaScript</li>
</ul>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    var li = $('li');
    li.map(function(index, elem){
        console.log(index, elem);
        $(elem).css('color', 'red');
    })
</script>




# jQuery 객체 API
var t = document.getElementById('active');


주요기능

식별자

문서내에서 특정한 엘리먼트를 식별하기 위한 용도로 사용되는 API

Element.classList
Element.className
Element.id
Element.tagName

조회
엘리먼트의 하위 엘리먼트를 조회하는 API

Element.getElementsByClassName
Element.getElementsByTagName
Element.querySelector
Element.querySelectorAll

속성
엘리먼트의 속성을 알아내고 변경하는 API

Element.getAttribute(name)
Element.setAttribute(name, value)
Element.hasAttribute(name);
Element.removeAttribute(name);


# 식별자 API

Element.tagName - 해당 엘리먼트의 태그 이름을 알아낸다. 태그 이름을 변경하지는 못한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active" class="important current">JavaScript</li>
</ul>
<script>
console.log(document.getElementById('active').tagName)
</script>

//Element.id - 문서에서 id는 단 하나만 등장할 수 있는 식별자다. 아래 예제는 id의 값을 읽고 변경하는 방법을 보여준다
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active">JavaScript</li>
</ul>
<script>
var active = document.getElementById('active');
console.log(active.id);
active.id = 'deactive';
console.log(active.id);
</script>

//Element.className - 클래스는 여러개의 엘리먼트를 그룹핑할 때 사용한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active">JavaScript</li>
</ul>
<script>
var active = document.getElementById('active');
// class 값을 변경할 때는 프로퍼티의 이름으로 className을 사용한다.
active.className = "important current";
console.log(active.className);
// 클래스를 추가할 때는 아래와 같이 문자열의 더한다.
active.className += " readed"
</script>


//Element.classList - className에 비해서 훨씬 편리한 사용성을 제공한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active" class="important current">JavaScript</li>
</ul>
<script>
function loop(){
    for(var i=0; i<active.classList.length; i++){
        console.log(i, active.classList[i]);
    }
}
#  클래스를 추가
</script>
<input type="button" value="DOMTokenList" onclick="console.log(active.classList);" />
<input type="button" value="조회" onclick="loop();" />
<input type="button" value="추가" onclick="active.classList.add('marked');" />
<input type="button" value="제거" onclick="active.classList.remove('important');" />
<input type="button" value="토글" onclick="active.classList.toggle('current');" />


//active.classList.add('haru'); 추가
//active.classList.remove('haru'); 삭제
//active.classList.toggle('haru'); 토글(있으면 삭제, 없으면 추가)




# 조회 API
<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked">DOM</li>
            <li class="marked">BOM</li>
        </ul>
    </li>
</ul>
<script>
    var list = document.getElementsByClassName('marked');
    console.group('document');
    for(var i=0; i<list.length; i++){
        console.log(list[i].textContent);
    }
    console.groupEnd();

    console.group('active');
    var active = document.getElementById('active');     
    var list = active.getElementsByClassName('marked');
    for(var i=0; i<list.length; i++){
        console.log(list[i].textContent);
    }
    console.groupEnd();
</script>



# 속성 API

Element.getAttribute(name)
Element.setAttribute(name, value)
Element.hasAttribute(name);
Element.removeAttribute(name);

<a id="target" href="http://opentutorials.org">opentutorials</a>
<script>
var t = document.getElementById('target');
console.log(t.getAttribute('href')); //http://opentutorials.org
t.setAttribute('title', 'opentutorials.org'); // title 속성의 값을 설정한다.
console.log(t.hasAttribute('title')); // true, title 속성의 존재여부를 확인한다.
t.removeAttribute('title'); // title 속성을 제거한다.
console.log(t.hasAttribute('title')); // false, title 속성의 존재여부를 확인한다.
</script>


# 속성과 프로퍼티
<p id="target">
    Hello world
</p>
<script>
    var target = document.getElementById('target');
    // attribute 방식
    target.setAttribute('class', 'important');
    // property 방식
    target.className = 'important';
</script>





<a id="target" href="./demo1.html">ot</a>
<script>
//현재 웹페이지가 http://localhost/webjs/Element/attribute_api/demo3.html 일 때 
var target = document.getElementById('target');
// http://localhost/webjs/Element/attribute_api/demo1.html 
console.log('target.href', target.href);
// ./demo1.html 
console.log('target.getAttribute("href")', target.getAttribute("href"));
</script>



# jQuery 속성 제어 API

<a id="target" href="http://opentutorials.org">opentutorials</a>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
var t = $('#target');
console.log(t.attr('href')); //http://opentutorials.org
t.attr('title', 'opentutorials.org'); // title 속성의 값을 설정한다.
t.removeAttr('title'); // title 속성을 제거한다.
</script>


# attribute와 property
DOM과 마찬가지로 jQuery도 속성(attribute)과 프로퍼티를 구분한다. 속성은 attr, 프로퍼티는 prop 메소드를 사용한다.

<a id="t1" href="./demo.html">opentutorials</a>
<input id="t2" type="checkbox" checked="checked" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
//  현재 문서의 URL이 아래와 같다고 했을 때
//  http://localhost/jQuery_attribute_api/demo2.html
var t1 = $('#t1');
console.log(t1.attr('href')); // ./demo.html 
console.log(t1.prop('href')); // http://localhost/jQuery_attribute_api/demo.html 
 
var t2 = $('#t2');
console.log(t2.attr('checked')); // checked
console.log(t2.prop('checked')); // true
</script>



<div id="t1">opentutorials</div>
<div id="t2">opentutorials</div>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
$('#t1').prop('className', 'important'); 
$('#t2').prop('class', 'current');  
</script>



# jQuery 조회 범위 제한

# selector context
<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked">DOM</li>
            <li class="marked">BOM</li>
        </ul>
    </li>
</ul>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $( ".marked", "#active").css( "background-color", "red" );
</script>

//실행 결과

<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked" style="background-color: red;">DOM</li>
            <li class="marked" style="background-color: red;">BOM</li>
        </ul>
    </li>
</ul>

같은 코딩
$( "#active .marked").css( "background-color", "red" );





# .find()
$( "#active").find('.marked').css( "background-color", "red" );

$('#active').css('color','blue').find('.marked').css( "background-color", "red" );

# find를 너무 복잡하게 사용하면 코드를 유지보수하기 어렵게 된다. 



# Node 관계 API

Node.childNodes
자식노드들을 유사배열에 담아서 리턴한다.
Node.firstChild
첫번째 자식노드
Node.lastChild
마지막 자식노드
Node.nextSibling
다음 형제 노드
Node.previousSibling
이전 형제 노드


<body id="start">
<ul>
    <li><a href="./532">html</a></li> 
    <li><a href="./533">css</a></li>
    <li><a href="./534">JavaScript</a>
        <ul>
            <li><a href="./535">JavaScript Core</a></li>
            <li><a href="./536">DOM</a></li>
            <li><a href="./537">BOM</a></li>
        </ul>
    </li>
</ul>
<script>
var s = document.getElementById('start');
console.log(1, s.firstChild); // #text
var ul = s.firstChild.nextSibling
console.log(2, ul); // ul
console.log(3, ul.nextSibling); // #text
console.log(4, ul.nextSibling.nextSibling); // script
console.log(5, ul.childNodes); //text, li, text, li, text, li, text
console.log(6, ul.childNodes[1]); // li(html)
console.log(7, ul.parentNode); // body
</script>
</body>


# 노드 종류 API

노드 작업을 하게 되면 현재 선택된 노드가 어떤 타입인지를 판단해야 하는 경우가 있다. 이런 경우에 사용할 수 있는 API가 nodeType, nodeName이다. 

Node.nodeType
node의 타입을 의미한다. 
Node.nodeName
node의 이름 (태그명을 의미한다.)

# Node Type
노드의 종류에 따라서 정해진 상수가 존재한다. 아래는 모든 노드의 종류와 종류에 따른 값을 출력하는 예제다.
for(var name in Node){
   console.log(name, Node[name]);
}
# 결과
ELEMENT_NODE 1 
ATTRIBUTE_NODE 2 
TEXT_NODE 3 
CDATA_SECTION_NODE 4 
ENTITY_REFERENCE_NODE 5 
ENTITY_NODE 6 
PROCESSING_INSTRUCTION_NODE 7 
COMMENT_NODE 8 
DOCUMENT_NODE 9 
DOCUMENT_TYPE_NODE 10 
DOCUMENT_FRAGMENT_NODE 11 
NOTATION_NODE 12 
DOCUMENT_POSITION_DISCONNECTED 1 
DOCUMENT_POSITION_PRECEDING 2 
DOCUMENT_POSITION_FOLLOWING 4 
DOCUMENT_POSITION_CONTAINS 8 
DOCUMENT_POSITION_CONTAINED_BY 16 
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC 32

# 함수가 자기 자신을 호출하는 것을 재귀함수라고 하는데 본 예제는 재귀 함수의 예를 보여준다.







# 노드 종류 API

<!DOCTYPE html>
<html>
<body id="start">
<ul>
    <li><a href="./532">html</a></li> 
    <li><a href="./533">css</a></li>
    <li><a href="./534">JavaScript</a>
        <ul>
            <li><a href="./535">JavaScript Core</a></li>
            <li><a href="./536">DOM</a></li>
            <li><a href="./537">BOM</a></li>
        </ul>
    </li>
</ul>
<script>
function traverse(target, callback){
    if(target.nodeType === 1){
        //if(target.nodeName === 'A')
        callback(target);
        var c = target.childNodes;
        for(var i=0; i<c.length; i++){
            traverse(c[i], callback);       
        }   
    }
}
traverse(document.getElementById('start'), function(elem){
    console.log(elem);
});
</script>
</body>
</html>


# jQuery 노드 변경 API

<div class="target">
    content1
</div>
 
<div class="target">
    content2
</div>
 
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('.target').before('<div>before</div>');
    $('.target').after('<div>after</div>');
    $('.target').prepend('<div>prepend</div>');
    $('.target').append('<div>append</div>');
</script>


# 제거
# 제거와 관련된 API는 remove와 empty가 있다. remove는 선택된 엘리먼트를 제거하는 것이고 empty는 선택된 엘리먼트의 텍스트 노드를 제거하는 것이다.

<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<input type="button" value="remove target 1" id="btn1" />
<input type="button" value="empty target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#target1').remove();
    })
    $('#btn2').click(function(){
        $('#target2').empty();
    })
</script>


# 바꾸기
replaceAll과 replaceWith는 모두 노드의 내용을 교체하는 API이다. replaceWith가 제어 대상을 먼저 지정하는 것에 반해서 replaceAll은 제어 대상을 인자로 전달한다.

<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<input type="button" value="replaceAll target 1" id="btn1" />
<input type="button" value="replaceWith target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('<div>replaceAll</div>').replaceAll('#target1');
    })
    $('#btn2').click(function(){
        $('#target2').replaceWith('<div>replaceWith</div>');
    })
</script>


# 복사
<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<div id="source">source</div>
 
<input type="button" value="clone replaceAll target 1" id="btn1" />
<input type="button" value="clone replaceWith target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#source').clone().replaceAll('#target1');
    })
    $('#btn2').click(function(){
        $('#target2').replaceWith($('#source').clone());
    })
</script>



# 이동
<div class="target" id="target1">
    target 1
</div>
 
<div id="source">source</div>
 
<input type="button" value="append source to target 1" id="btn1" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#target1').append($('#source'));
    })
</script>



# 문자열로 노드 제어
# innerHTML
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.innerHTML);
    }
    function set(){
        var target = document.getElementById('target');
        target.innerHTML = "<li>JavaScript Core</li><li>BOM</li><li>DOM</li>";
    }
</script>

# outerHTML
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.outerHTML);
    }
    function set(){
        var target = document.getElementById('target');
        target.outerHTML = "<ol><li>JavaScript Core</li><li>BOM</li><li>DOM</li></ol>";
    }
</script>



# innerText, outerText
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.innerText);
    }
    function set(){
        var target = document.getElementById('target');
        target.innerText = "<li>JavaScript Core</li><li>BOM</li><li>DOM</li>";
    }
</script>


# insertAdjacentHTML()

<ul id="target">
    <li>CSS</li>
</ul>
<input type="button" onclick="beforebegin();" value="beforebegin" />
<input type="button" onclick="afterbegin();" value="afterbegin" />
<input type="button" onclick="beforeend();" value="beforeend" />
<input type="button" onclick="afterend();" value="afterend" />
<script>
    function beforebegin(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('beforebegin','<h1>Client Side</h1>');
    }
    function afterbegin(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('afterbegin','<li>HTML</li>');
    }
    function beforeend(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('beforeend','<li>JavaScript</li>');
    }
    function afterend(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('afterend','<h1>Server Side</h1>');
    }
</script>



# 값 API
<ul>
    <li id="target">html</li> 
    <li>css</li>
    <li>JavaScript</li>
</ul>
<script>
    var t = document.getElementById('target').firstChild;
    console.log(t.nodeValue);
    console.log(t.data);
</script>


# 조작 API
appendData()
deleteData()
insertData()
replaceData()
substringData()

<!DOCTYPE html>
<html>
<head>
    <style>
    #target{
        font-size:77px;
        font-family: georgia;
        border-bottom:1px solid black;
        padding-bottom:10px;
    }
    p{
        margin:5px;
    }
    </style>
</head>
<body>
<p id="target">Cording everybody!</p>
<p> data : <input type="text" id="datasource" value="JavaScript" /></p>
<p>   start :<input type="text" id="start" value="5" /></p>
<p> end : <input type="text" id="end" value="5" /></p>
<p><input type="button" value="appendData(data)" onclick="callAppendData()" />
<input type="button" value="deleteData(start,end)" onclick="callDeleteData()" />
<input type="button" value="insertData(start,data)" onclick="callInsertData()" />
<input type="button" value="replaceData(start,end,data)" onclick="callReplaceData()" />
<input type="button" value="substringData(start,end)" onclick="callSubstringData()" /></p>
<script>
    var target = document.getElementById('target').firstChild;
    var data = document.getElementById('datasource');
    var start = document.getElementById('start');
    var end = document.getElementById('end');
    function callAppendData(){
        target.appendData(data.value);
    }
    function callDeleteData(){
        target.deleteData(start.value, end.value);
    }
    function callInsertData(){
        target.insertData(start.value, data.value); 
    }
    function callReplaceData(){
        target.replaceData(start.value, end.value, data.value);
    }
    function callSubstringData(){
        alert(target.substringData(start.value, end.value));
    }
</script>
</body>
</html>


#  요소의 크기와 위치 
#  getBoundingClientRect()
#  offsetParent
# ClientWidth, ClientHeight

<style>
    body{
        padding:0;
        margin:0;
    }
    #target{
        width:100px;
        height:100px;
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
</style>
<div id="target">
    Coding
</div>
<script>
var t = document.getElementById('target');
console.log(t.getBoundingClientRect());
console.log(t.offsetParent);
</script>


# getBoundingClientRect의 width 값을 IE는 제공하지 않는다.


# Viewport
1초에 한번씩 getBoundingClientRect의 top 속성과 window.pageYOffset의 값이 출력된다.

<style>
    body{
        padding:0;
        margin:0;
    }
    div{
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
    #target{
        width:100px;
        height:2000px;
    }
</style>
    <div>
        <div id="target">
            Coding
        </div>
    </div>

<script>
var t = document.getElementById('target');
setInterval(function(){
    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset);
}, 1000)
</script>


# 오래된 브라우저에서는 pageYOffset 대신 scrollTop 속성을 사용해야 한다.


# 문서의 좌표
그럼 문서의 좌표를 알고 싶으면 어떻게 해야 하나? 뷰포트의 좌표에 스크롤된 정도를 더해서 알 수 있다. 아래와 같이 코드를 조금 수정했다

setInterval(function(){
    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset, 'document y:', t.getBoundingClientRect().top+window.pageYOffset);
}, 1000)


# 스크롤
<style>
    body{
        padding:0;
        margin:0;
    }
    div{
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
    #target{
        width:100px;
        height:2000px;
    }
</style>
<input type="button" id="scrollBtn" value="scroll(0, 1000)" />
<script>
    document.getElementById('scrollBtn').addEventListener('click', function(){
        window.scrollTo(0, 1000);
    })
</script>
<div>
    <div id="target">
        Coding
    </div>
</div>



1920*1080

# 스크린의 크기
window.inner*은 뷰포트의 크기를 나타내고, screen.*은 스크린의 크기를 나타낸다.

<script>
console.log('window.innerWidth:', window.innerWidth, 'window.innerHeight:', window.innerHeight);
console.log('screen.width:', screen.width, 'screen.height:', screen.height);
</script>


# 이벤트란?
이벤트(event)는 어떤 사건을 의미한다. 브라우저에서의 사건이란 사용자가 클릭을 했을 '때', 스크롤을 했을 '때', 필드의 내용을 바꾸었을 '때'와 같은 것을 의미한다. 

<!DOCTYPE html>
<html>
<body>
    <input type="button" onclick="alert(window.location)" value="alert(window.href)" />
    <input type="button" onclick="window.open('bom.html')" value="window.open('bom.html')" />
</body>
</html>

onclick 속성의 자바스크립트 코드(alert(window.location))는 사용자가 이 버튼을 클릭 했을 '때' 실행된다. 즉 js 개발자는 어떤 일이 발생했을 때 실행 되어야 하는 코드를 등록하고, 브라우저는 그 일이 발생했을 때 등록된 코드를 실행하게 된다. 이러한 방식을 이벤트 프로그래밍이라고 한다.

# event target
<input type="button" onclick="alert(window.location)" value="alert(window.href)" />

# event type
이벤트의 종류를 의미한다. 위의 예제에서는 click이 이벤트 타입이다. 그 외에도 scroll은 사용자가 스크롤을 움직였다는 이벤트이고, mousemove는 마우스가 움직였을 때 발생하는 이벤트이다.

# event handler
이벤트가 발생했을 때 동작하는 코드를 의미한다. 위의 예제에서는 alert(window.location)이 여기에 해당한다.


# inline
인라인(inline) 방식으로 이벤트를 등록하는 방법을 알아보자. 인라인 방식은 이벤트를 이벤트 대상의 태그 속성으로 지정하는 것이다. 다음은 버튼을 클릭했을 때 Hello world를 경고창으로 출력한다.

<input type="button" onclick="alert('Hello world');" value="button" />
이벤트가 발생한 대상을 필요로하는 경우 this를 통해서 참조할 수 있다.


<!--자기 자신을 참조하는 불편한 방법-->
<input type="button" id="target" onclick="alert('Hello world, '+document.getElementById('target').value);" value="button" />
<!--this를 통해서 간편하게 참조할 수 있다-->
<input type="button" onclick="alert('Hello world, '+this.value);" value="button" />

인라인 방식은 태그에 이벤트가 포함되기 때문에 이벤트의 소재를 파악하는 것이 편리하다. 하지만 정보인 HTML과 제어인 JavaScript가 혼재된 형태이기 때문에 바람직한 방법이라고 할수는 없다. 


# 프로퍼티 리스너

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>MisterHaru Clan Scrim</title>
        <style>
    
        </style>
    </head>
    <body>
        <input type="button" id="target" value="button" />

        <script>
            var t = document.getElementById('target');
            t.onclick = function(event){
                var event = event || window.event;
                //alert('Hello World, '+event.target.value)
                console.dir(event);
                console.log(event.target);
            }
        </script>
    </body>
</html>

# 이벤트 객체
이벤트가 실행된 맥락의 정보가 필요할 때는 이벤트 객체를 사용한다. 이벤트 객체는 이벤트가 실행될 때 이벤트 핸들러의 인자로 전달된다. 
<body>
    <input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.onclick = function(event){
        alert('Hello world, '+event.target.value)
    }
</script>

//ie8 이하 버전에서는 이벤트 객체를 핸들러의 인자가 아니라 전역객체의 event 프로퍼티로 제공한다. 또한 target 프로퍼티도 지원하지 않는다. 아래는 이 문제를 해소하기 위한 코드다.
<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.onclick = function(event){
        var event = event || window.event;
        var target = event.target || event.srcElement;
        alert('Hello world, '+target.value)
    }
</script>


# addEventListener()
addEventListener은 이벤트를 등록하는 가장 권장되는 방식이다. 이 방식을 이용하면 여러개의 이벤트 핸들러를 등록할 수 있다.


<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.addEventListener('click', function(event){
        alert('Hello world, '+event.target.value);
    });
</script>


이 방식은 ie8이하에서는 호환되지 않는다. ie에서는 attachEvent 메소드를 사용해야 한다. 

var t = document.getElementById('target');
if(t.addEventListener){
    t.addEventListener('click', function(event){
        alert('Hello world, '+event.target.value);
    }); 
} else if(t.attachEvent){
    t.attachEvent('onclick', function(event){
        alert('Hello world, '+event.target.value);
    })
}

이 방식의 중요한 장점은 하나의 이벤트 대상에 복수의 동일 이벤트 타입 리스너를 등록할 수 있다는 점이다. 

<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.addEventListener('click', function(event){
        alert(1);
    });
    t.addEventListener('click', function(event){
        alert(2);
    });
</script>

이벤트 객체를 이용하면 복수의 엘리먼트에 하나의 리스너를 등록해서 재사용할 수 있다. 

<input type="button" id="target1" value="button1" />
<input type="button" id="target2" value="button2" />
<script>
    var t1 = document.getElementById('target1');
    var t2 = document.getElementById('target2');
    function btn_listener(event){
        switch(event.target.id){
            case 'target1':
                alert(1);
                break;
            case 'target2':
                alert(2);
                break;
        }
    }
    t1.addEventListener('click', btn_listener);
    t2.addEventListener('click', btn_listener);
</script>



## 이벤트 전파(버블링과 캡처링)

<html>
    <head>
        <style>
            html{border:5px solid red;padding:30px;}
            body{border:5px solid green;padding:30px;}
            fieldset{border:5px solid blue;padding:30px;}
            input{border:5px solid black;padding:30px;}
        </style>
    </head>
    <body>
        <fieldset>
            <legend>event propagation</legend>
            <input type="button" id="target" value="target">          
        </fieldset>
        <script>
        function handler(event){
            var phases = ['capturing', 'target', 'bubbling']
            console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
        }
        document.getElementById('target').addEventListener('click', handler, true);
        document.querySelector('fieldset').addEventListener('click', handler, true);
        document.querySelector('body').addEventListener('click', handler, true);
        document.querySelector('html').addEventListener('click', handler, true);
        </script>
    </body>
</html>

//실행결과
INPUT HTML capturing
INPUT BODY capturing
INPUT FIELDSET capturing
INPUT INPUT target

이벤트가 부모에서부터 발생해서 자식으로 전파되고 있다. 이러한 방식을 capturing이라고 한다

document.getElementById('target').addEventListener('click', handler, false);
document.querySelector('fieldset').addEventListener('click', handler, false);
document.querySelector('body').addEventListener('click', handler, false);
document.querySelector('html').addEventListener('click', handler, false);

//아래처럼 코드를 변경해보자.
function handler(event){
    var phases = ['capturing', 'target', 'bubbling']
    console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
}
function stophandler(event){
    var phases = ['capturing', 'target', 'bubbling']
    console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
    event.stopPropagation();
}
document.getElementById('target').addEventListener('click', handler, false);
document.querySelector('fieldset').addEventListener('click', handler, false);
document.querySelector('body').addEventListener('click', stophandler, false);
document.querySelector('html').addEventListener('click', handler, false);


//실행결과
INPUT INPUT target
INPUT FIELDSET bubbling
INPUT BODY bubbling

//stopPropagation


# 기본동작의 취소

//inline
이벤트의 리턴값이 false이면 기본 동작이 취소된다.

<p>
    <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
</p>
<p>
    <a href="http://opentutorials.org" onclick="if(document.getElementById('prevent').checked) return false;">opentutorials</a>
</p>
<p>
    <form action="http://opentutorials.org" onsubmit="if(document.getElementById('prevent').checked) return false;">
            <input type="submit" />
    </form>
</p>


//property 방식
리턴 값이 false이면 기본동작이 취소된다

<p>
    <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
</p>
<p>
    <a href="http://opentutorials.org">opentutorials</a>
</p>
<p>
    <form action="http://opentutorials.org">
            <input type="submit" />
    </form>
</p>
<script>
    document.querySelector('a').onclick = function(event){
        if(document.getElementById('prevent').checked)
            return false;
    };
    
    document.querySelector('form').onclick = function(event){
        if(document.getElementById('prevent').checked)
            return false;
    };

</script>

//addEventListener 방식
이 방식에서는 이벤트 객체의 preventDefault 메소드를 실행하면 기본 동작이 취소된다.

<p>
            <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
        </p>
        <p>
            <a href="http://opentutorials.org">opentutorials</a>
        </p>
        <p>
            <form action="http://opentutorials.org">
                    <input type="submit" />
            </form>
        </p>
        <script>
            document.querySelector('a').addEventListener('click', function(event){
                if(document.getElementById('prevent').checked)
                    event.preventDefault();
            });
            
            document.querySelector('form').addEventListener('submit', function(event){
                if(document.getElementById('prevent').checked)
                    event.preventDefault();
            });

        </script>


# 이벤트 타입
	
<input type="button" onclick="alert(1);" />

//폼
//submit
submit은 폼의 정보를 서버로 전송하는 명령인 submit시에 일어난다.

form 태그에 적용된다.

아래 예제는 전송 전에 텍스트 필드에 값이 입력 되었는지를 확인한다. 만약 값이 입력되지 않았다면 전송을 중단한다.

<form id="target" action="result.html">
    <label for="name">name</label> <input id="name" type="name" />
    <input type="submit" />
</form>
<script>
var t = document.getElementById('target');
t.addEventListener('submit', function(event){
    if(document.getElementById('name').value.length === 0){
        alert('Name 필드의 값이 누락 되었습니다');
        event.preventDefault();
    }
});
</script>


# event.preventDefault();

//change
change는 폼 컨트롤의 값이 변경 되었을 때 발생하는 이벤트다.

input(text,radio,checkbox), textarea, select 태그에 적용된다.

<p id="result"></p>
<input id="target" type="name" />
<script>
var t = document.getElementById('target');
t.addEventListener('change', function(event){
    document.getElementById('result').innerHTML=event.target.value;
});
</script>


//blur, focus
focus는 엘리먼트에 포커스가 생겼을 때, blur은 포커스가 사라졌을 때 발생하는 이벤트다. 

다음 태그를 제외한 모든 태그에서 발생한다. <base>, <bdo>, <br>, <head>, <html>, <iframe>, <meta>, <param>, <script>, <style>, <title>

<input id="target" type="name" />
<script>
var t = document.getElementById('target');
t.addEventListener('blur', function(event){
    alert('blur');  
});
t.addEventListener('focus', function(event){
    alert('focus'); 
});
</script>



# 문서 로딩
웹페이지를 프로그래밍적으로 제어하기 위해서는 웹페이지의 모든 요소에 대한 처리가 끝나야 한다. 이것을 알려주는 이벤트가 load, DOMContentLoaded이다.

아래 코드의 실행결과는 null이다. <p id="target">Hello</p>가 로딩되기 전에 자바스크립트가 실행되었기 때문이다.

<html>
    <head>
        <script>
            window.addEventListener('load', function(){
                console.log('load');
            })
            window.addEventListener('DOMContentLoaded', function(){
                console.log('DOMContentLoaded');
            })
        </script>
    </head>
    <body>
        <p id="target">Hello</p>
    </body>
</html>


# 마우스
//이벤트 타입
웹브라우저는 마우스와 관련해서 다양한 이벤트 타입을 지원한다.

click
클릭했을 때 발생하는 이벤트. 
dblclick
더블클릭을 했을 때 발생하는 이벤트
mousedown
마우스를 누를 때 발생
mouseup
마우스버튼을 땔 때 발생
mousemove
마우스를 움직일 때
mouseover
마우스가 엘리먼트에 진입할 때 발생
mouseout
마우스가 엘리먼트에서 빠져나갈 때 발생
contextmenu
컨텍스트 메뉴가 실행될 때 발생


# //키보드 조합  https://www.opentutorials.org/

<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>li {padding:10px; list-style: none}</style>
</head>

<body>

    
    <style>
        body{
            padding:0;
            margin:0;
        }
        div{
            border:50px solid #1065e6;
            padding:50px;
            margin:50px;
        }
        #target{
            width:100px;
            height:2000px;
        }
    </style>
    <input type="button" id="scrollBtn" value="scroll(0, 1000)" />
    <script>
        document.getElementById('scrollBtn').addEventListener('click', function(){
            window.scrollTo(0, 1000);
        })
    </script>
    <div>
        <div id="target">
            Coding
        </div>
    </div>
</body>
</html>



# 코드잇 자바스크립트 수업 내용

# 함수

function expressMultiplication(a, b) {
  console.log(String(a) + " * " + String(b) + " = " + String(a * b));
}
// 테스트 코드
expressMultiplication(3, 4);
expressMultiplication(3, 2);
expressMultiplication(7, 5);
expressMultiplication(8, 9);
expressMultiplication(5, 5);
expressMultiplication(9, 9);

</> 실행 결과
3 * 4 = 12
3 * 2 = 6
7 * 5 = 35
8 * 9 = 72
5 * 5 = 25
9 * 9 = 81


# return
return: 돌려주다
미국 단위인 '인치(inch)'를 '센티미터(cm)'로 변환 시켜주는 함수 inchToCentimeter를 작성했습니다.

(1)  function inchToCentimeter(inch) {
(2)      var centimeter = inch * 2.54;  // 1 inch = 2.54cm
(3)      return centimeter;             // cm로 계산한 결괏값 돌려주기
(4)  }
(5)  
(6)  var result1 = inchToCentimeter(2); // 2 inch를 cm로 바꾼 값
(7)  var result2 = inchToCentimeter(3); // 3 inch를 cm로 바꾼 값
(8) 
(9)  console.log(result1);
(10) console.log(result2);
(11) console.log(inchToCentimeter(1) + inchToCentimeter(5));
5.08
7.62
15.24
코드를 보면 return이라는 게 있죠? 'return'은 한국말로 '돌려주다'입니다. 누가 누구에게 무엇을 돌려준다는 얘기일까요?

6번 줄을 보시면 inchToCentimeter 함수가 호출됩니다.
inch의 값으로 2가 들어가기 때문에 centimeter에는 2 * 2.54인 5.08이 들어갑니다.
3번 줄에서 return centimeter를 하기 때문에 inchToCentimeter 함수는 5.08을 '돌려주게' 됩니다.
함수를 호출한 부분인 inchToCentimeter(2)는 5.08을 '돌려받아서', inchToCentimeter(2)가 5.08로 대체된다고 보시면 됩니다. 따라서 result1에는 5.08이 저장됩니다.
7번 줄에도 함수 호출이 있고, 11번 줄에는 함수 호출이 두 개가 있습니다. 콘솔에 7.62와 15.24가 출력되는 과정 이해 되시나요?


======

function calculateRectangleArea(x, y) {
    var ares = x * y;
    return ares;
}


// 테스트 코드
var area1 = calculateRectangleArea(3, 4); // 가로 3, 세로 4인 직사각형의 넓이 계산
var area2 = calculateRectangleArea(5, 8); // 가로 5, 세로 8인 직사각형의 넓이 계산
var area3 = calculateRectangleArea(7, 2); // 가로 7, 세로 2인 직사각형의 넓이 계산

console.log('Area1: ' + area1 + ', Area2: ' + area2 + ', Area3: ' + area3);


# 정답
function calculateRectangleArea(x, y) {
    return x * y;
}

# 형 변환 함수
우리도 이미 내장 함수를 쓴 적이 있습니다.

바로 형 변환 함수!

String(3);
Number('7');
첫 줄의 함수 이름은 String이고, 파라미터로 숫자 3을 받고, 문자열 '3'을 리턴해주는 거죠. 두 번째 줄의 함수 이름은 Number이고, 파라미터로 문자열 '7'을 받고 숫자 7을 리턴해줍니다.

이 두 함수는 분명 우리가 선언을 안 했는데도 잘 작동하네요. 자바스크립트 내부에서 미리 선언을 해준 것입니다. 숫자를 문자열로, 또는 문자열을 숫자로 바꾸는 함수는 누구에게나 필요할 것 같아서 이미 구현되어 있습니다.

# parseInt 함수
Number 함수와 비슷한 parseInt라는 함수도 있는데요. Number와는 조금 다르게, 파라미터가 '100세'처럼 숫자랑 문자가 섞여 있으면 숫자만 꺼내서 변환시켜줍니다.

parseInt('100세');
parseInt('세100');
100
NaN
하지만 보시다시피 숫자가 앞에 있어야 제대로 작동합니다. parseInt('세100')을 했을 때 나오는 NaN은 'Not a Number(숫자가 아니다)'의 약자입니다.

# 그 외의 내장 함수
alert, prompt, console.log도 자바스크립트에서 미리 준비해둔 함수들입니다. 내장 함수를 잘 알아두면 우리의 코딩 시간을 단축할 수 있겠죠?

이 외에도 다양한 내장 함수가 준비되어있지만 사용법은 동일합니다. 보통은 필요할 때 즉석에서 찾아보고 활용하는 경우가 많습니다.


String()	숫자를 문자열로 변환해주는 함수.
Number()	문자열을 숫자로 변환해주는 함수.
parseInt()	문자열 안에서 정수를 뽑아주는 함수.
parseFloat()	문자열 안에서 숫자(소수 포함)를 뽑아주는 함수.
alert()	사용자에게 메시지를 띄워주는 함수.
prompt()	사용자에게 메시지를 띄우고, 문자열을 입력받는 함수.
confirm()	사용자에게 메시지를 띄우고, 확인과 취소 중 하나를 누르게 하는 함수.





# if문
<script>
var inputNumber = window.prompt("한 자리 숫자를 적어주세요.");

if (inputNumber === '7') {
    alert('Lucky!');
}   else if (inputNumber === '0') {
    alert('Zero');
}   else if (inputNumber === '1') {
    alert('One');
}   else {
    alert('Unlucky!');
}
</script>

# 14가 6의 배수인지 확인
var num = 14;
if (num % 2 === 0 && num % 3 === 0) {
    console.log(num + '는 6의 배수입니다.');
} else {
    console.log(num + '는 6의 배수가 아닙니다.');
}

## 숫자를 입력 받을수 있도록 재 코딩
var inputNumber = window.prompt("6의 배수를 적어주세요.");

if (inputNumber % 2 === 0 && inputNumber % 3 === 0) {
    console.log(inputNumber + '는 6의 배수입니다.');
} else {
    console.log(inputNumber + '는 6의 배수가 아닙니다.');
}



<script>

function whatShouldICallYou(myAge, myGender, yourAge, yourGender) {
    // 나의 나이, 나의 성별, 상대방의 나이, 상대방의 성별
    // 총 4개의 정보를 활용해서 호칭을 결정해보세요.
if (myAge === yourAge){
    return "친구";
} else if (myAge > yourAge) {
    if (yourGender === "male") {
    return "남동생";
} else if (yourGender === "female") {
    return "여동생";
} 
} else if (myGender === "male") {
    if (yourGender === "male") {
    return "형";
    } else if (yourGender === "female") {
    return "누나";
    }
} else if (myGender === "female") {
    if (yourGender === "male") {
    return "오빠";
    } else if (yourGender === "female") {
    return "언니";
    }
}
}
// 테스트 코드
var result1 = whatShouldICallYou(23, 'male', 25, 'female');
var result2 = whatShouldICallYou(21, 'female', 21, 'female');
var result3 = whatShouldICallYou(25, 'female', 22, 'male');

console.log(result1);
console.log(result2);
console.log(result3);

</script>


# switch문
// switch 문 뒤에 break를 꼭 넣어 줘야 한다. 그렇지 않으면 뒤쪽에 모두 alert가 표시 된다.


switch (inputNumber) {
    case '0':
        alert('Zero!');
        break;
    case '1':
        alert('Oneo!');
        break;
    case '7':
        alert('Lucky!');
        break;
    default:
        alert('Unlucky!');
        break;
}


# 파이썬은  switch문이 없으므로 if문으로 작성해야 한다. 자바스크립트에서만 스위치문 사용

# for반복문

for (초기화부분; 조건부분; 추가동작부분) {
    동작부분
}

for ( let i = 1; i <= 10; i++) {
    console.log('${i} 미스터하루');
}




# 문제 : 주어진 높이(height)에 맞게 *로 삼각형을 그려주는 함수 printTriangle을 써봅시다. 출력 결과는 아래를 참고해주세요.


높이: 5
*
**
***
****
*****
높이: 3
*
**
***
높이: 1
*


function printTriangle(height) {
    // 이 함수 안에서 console.log를 직접 사용하여
    // 직접 출력까지 완료해야 합니다.
    // 이 함수는 return 값이 없습니다.
    text = '';
    for(var i = 0; i < height; i = i + 1){
        text = text + '*';
        console.log(text);
    }
}

// 테스트 코드
console.log('높이: 5');
printTriangle(5);

console.log('높이: 3');
printTriangle(3);

console.log('높이: 1');
printTriangle(1);



# 문제

1등만 기억하는 세상을 타파하기 위해, 2등을 찾아보는 프로그램을 만들기로 했습니다.

파라미터로 배열 arr을 받고, arr에서 두 번째로 큰 숫자를 리턴시켜주는 함수 getSecondBiggestNumber를 작성해주세요.

코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

7
80
6


function getSecondBiggestNumber(arr) {
    // 코드를 작성하세요.
    var first = arr[0];
    var second = arr[1];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] > first) {
            second = first;
            first = arr[i];
        } else if (arr[i] > second) {
            second = arr[i]
        }
    }
    return second;
}

// 테스트 코드
console.log(getSecondBiggestNumber([4, 7, 2, 1, 9, 3, 6, 5]));
console.log(getSecondBiggestNumber([80, 2, 44, 21, 92, 3, 51]));
console.log(getSecondBiggestNumber([4, 7, 6, 5]));


# for of반복문

var brand = ['NIKE', 'ADIDA', 'REEBOK'];

for (var value of brands) {
    console.log(value);
}

=====

for (var [변수] of brands) {
    console.log(변수);
}



for...in문과 for...of문의 차이
우선 for...in문과 for...of문의 차이부터 살펴봅시다.

var arr =  ['Americano', 'Latte', 'Tea'];

// for...of
for (var v of arr) {
  console.log(v);
}

console.log('---');

// for...in
for (var k in arr) {
  console.log(k);
}
Americano
Latte
Tea
---
0
1
2
차이점이 보이시나요?

배열은 여러 개의 index-value 쌍으로 이루어졌다고 볼 수 있는데요. 위 코드의 arr배열의 경우에 index는 0, 1, 2이고, value는 'Americano', 'Latte', 'Tea'입니다.

출력된 결과를 보시면 알 수 있듯 for...of문은 배열의 value에 직접 접근하는 반면, for...in문은 index에 접근합니다.

for...in문으로 value에 접근하기 위해서는 이렇게 바꿔줘야겠죠?

// for...in
for (var k in arr) {
  console.log(arr[k]);
}
Americano
Latte
Tea



# while 반복문
var brands = ['apple', 'coca-cola', 'starbucks', 'amazon', 'disney', 'BMW'];

var i = 0;

while (i < 6) {
    console.log(brands[i]);
    i++
}


# break문
만약 while문의 조건부분과 상관 없이 반복문에서 나오고 싶으면 break문을 쓰면 됩니다.

var i = 100;

while (true) {
    // i가 23의 배수면 반복문을 끝냄
    if (i % 23 == 0) {
        break;
    }
    i = i + 1;
}

console.log(i);

115


# continue문
만약 현재 진행되고 있는 수행부분을 중단시키고 바로 조건부분을 다시 확인하고 싶으면 continue문을 쓰면 됩니다.

var i = 0;

while (i < 15) {
    i = i + 1;

    // i가 홀수면 console.log(i) 안하고 바로 조건부분으로 돌아감
    if (i % 2 == 1) {
        continue;
    }
    console.log(i);
}


2
4
6
8
10
12
14

# 로그인 모듈
사용자에게 아이디와 비밀번호를 입력받아서 '로그인' 시키는 모듈을 아래 두 가지 방법으로 만들어봅시다:

1. 다섯 번의 기회만 주는 모듈
2. 성공할 때까지 기회를 무제한으로 주는 모듈

# 횟수 제한 (for문)
// 최대 다섯 번의 기회를 준다
for (var i = 0; i < 5; i++) {
  // 아이디와 비밀번호를 입력 받는다
  var id = window.prompt("아이디를 입력하세요");
  var password = window.prompt("비밀번호를 입력하세요");

  if (id === 'codeit' && password === '4321') {
    console.log('환영합니다. ' + id + '님.');
    break;
  } else {
    console.log('아이디와 비밀번호가 일치하지 않습니다.');
  }
}

# 무제한 (while문)

// 로그인 성공 여부를 보관하는 변수
var login = false;

// 로그인에 성공할 때까지 반복
while (!login) {
  // 아이디와 비밀번호를 입력 받는다
  var id = window.prompt("아이디를 입력하세요");
  var password = window.prompt("비밀번호를 입력하세요");

  if (id === 'codeit' && password === '4321') {
    console.log('환영합니다. ' + id + '님.');
    login = true;
  } else {
    console.log('아이디와 비밀번호가 일치하지 않습니다.');
  }
}

//for문과 while문의 차이를 눈치 채셨나요? 물론 이분법적으로 나눌 수 있는 얘기는 아니지만, 일반적으로 반복 횟수가 예측 가능할 때에는 for문을 사용하는 것이 더 눈에 잘 들어옵니다. 반대로 반복 횟수를 예측할 수 없으면 while문을 쓰는 것이 더 적합한 경우가 많겠죠?



#문제

0! = 1
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
6! = 6 * 5 * 4 * 3 * 2 * 1 = 720
파라미터로 정수 n을 받고 n!을 계산해서 리턴해주는 함수 factorial을 작성해주세요.

코드를 잘 작성하셨다면 아래와 같이 출력되어야 합니다.
3628800
120
6
1


function factorial(num) {
    var factorialValue = 1;
    // 코드를 작성하세요.
    if (num > 1) {
        for(var i = 1; i <= num; i++){
            factorialValue = factorialValue * i;
        }
    }
    return factorialValue;
}

console.log(factorial(10));
console.log(factorial(5));
console.log(factorial(3));
console.log(factorial(0));



더 간단하게 작성

function factorial(n) {
    var result = 1;

    for (var i = 1; i <= n; i++) {
        result = result * i;
    }
    return result;
}

// 테스트 코드
console.log(factorial(10));
console.log(factorial(5));
console.log(factorial(3));
console.log(factorial(0));


# 배열 만들기 I
배열에 push 메소드를 사용하면 배열 마지막 칸에 값이 추가됩니다
var arr = [2, 3, 5, 7];
arr.push(11);
console.log(arr);

[2, 3, 5, 7, 11]



# 문제
범위의 시작 지점(start), 끝 지점(end), 그리고 증가폭(step)을 파라미터로 받고, 그에 해당하는 배열을 리턴해주는 함수 range를 작성해주세요.


function range(start, end, step) {
    var arr = [];
    var idx = 0;

    if (start < end) {
        for (var i = start; i < end; i += step) {
            arr[idx] = i;
            idx++;
        }
    } else {
        for (var i = start; i > end; i += step) {
            arr[idx] = i;
            idx++;
        }
    }
    return arr;
}
// 테스트 코드
console.log(range(1, 10, 1));
console.log(range(-1, 10, 3));
console.log(range(10, -10, -4));

[1, 2, 3, 4, 5]
[3, 5, 7, 9]
[10, 6, 2, -2, -6]


# 문제
아래의 조건에 맞게 원래의 배열로 돌려놓는 함수 restoreArray를 만들어주세요.

2중 배열이 아닌, 하나의 배열로 통합한다.
배열 안의 배열에 있는 숫자들은 순서를 뒤바꾼다.
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4, 5, 6 ]

[
  3,  5, 4, 6,
  7, 10, 9, 8
]
먼저 2중 배열을 하나의 배열로 만들어봅시다.
for문을 사용하여 arr의 각 요소에 대해 length를 확인하고, 그 length만큼 다시 반복해주면서 returnArr에 추가합니다.

var arr1 = [[2, 1], [4, 3]];
var arr2 = [[3, 2, 1], [5, 4], [6]];
var arr3 = [[3], [4, 5], [6], [7], [8, 9, 10]];

function restoreArray(arr) {
    var returnArr = [];
    var idx = 0;

    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr[i].length; j++) {
            returnArr[idx] = arr[i][j];
            idx++;
        }
    }
    return returnArr;
}

console.log(restoreArray(arr1));
console.log(restoreArray(arr2));
console.log(restoreArray(arr3));

위와 같이 작성하면 하나의 배열로 만들었지만, 순서가 뒤집히지 않았습니다.
위의 코드를 조금 더 고쳐봅시다.

두 번째 for문에서, j를 0부터 arr[i].length까지 증가시키는 것이 아니라 arr[i].length부터 0까지 감소시키면 뒤집힌 순서로 추가할 수 있습니다.

var arr1 = [[2, 1], [4, 3]];
var arr2 = [[3, 2, 1], [5, 4], [6]];
var arr3 = [[3], [4, 5], [6], [7], [8, 9, 10]];

function restoreArray(arr) {
    var returnArr = [];
    var idx = 0;

    for (var i = 0; i < arr.length; i++) {
        for (var j = arr[i].length - 1; j >= 0; j--) {
            returnArr[idx] = arr[i][j];
            idx++;
        }
    }
    return returnArr;
}

console.log(restoreArray(arr1));
console.log(restoreArray(arr2));
console.log(restoreArray(arr3));

[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4, 5, 6 ]

[
  3,  5, 4, 6,
  7, 10, 9, 8
]

# 문제
// 코드를 입력해 주세요.
function teraToGiga(volume) {
  console.log(volume + 'TB는');
  console.log(volume * 1024 + 'GB 입니다.');
}

function teraToMega(volume) {
  console.log(volume + 'TB는');
  console.log(volume * 1024 * 1024 + 'MB 입니다.');
}

// TB -> GB 테스트
teraToGiga(2);

// TB -> MB 테스트
teraToMega(2);


function score(kill, win){
    result = kill + wing;
    console.log(result);
}
score(10,5);


# then 메소드 제대로 익히기

Promise 객체의 then 메소드를 제대로 이해해야 Promise Chaining을 잘 할 수 있습니다. then 메소드가 리턴한 Promise 객체가 그 콜백의 리턴값에 따라 어떻게 되는지, 이전 노트에서 배운 각각의 케이스를 코드잇 실행기에 준비해 두었는데요. 지금 각 케이스별로 아래와 같이 나뉘어 있습니다.

Case(1) : 콜백에서 Promise 객체를 리턴
Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴
Case(3) : 콜백에서 아무것도 리턴하지 않음
Case(4) : 콜백 실행 중 에러 발생 
Case(5) : 콜백이 실행되지 않음

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => {
  // return response.json(); // <- Case(1)
   //return 10; // <- Case(2)
    // // <- Case(3)
    //throw new Error('failed'); // <- Case(4)
})
  .then((result) => {
    console.log(result);
  });


Promise 객체의 then 메소드를 제대로 이해해야 Promise Chaining을 잘 할 수 있습니다. then 메소드가 리턴한 Promise 객체가 그 콜백의 리턴값에 따라 어떻게 되는지, 이전 노트에서 배운 각각의 케이스를 코드잇 실행기에 준비해 두었는데요. 지금 각 케이스별로 아래와 같이 나뉘어 있습니다.

Case(1) : 콜백에서 Promise 객체를 리턴
Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴
Case(3) : 콜백에서 아무것도 리턴하지 않음
Case(4) : 콜백 실행 중 에러 발생 
Case(5) : 콜백이 실행되지 않음

각 케이스별 코드 앞에 있는 주석을 선택적으로 해제 및 적용해가면서 각각 어떤 결과가 출력되는지 살펴보세요.

# 해설
then 메소드가 리턴한 Promise 객체를 A라고 했을 때, 각 경우에 A는 다음과 같은 상태와 결과를 갖게 됩니다.

Case(1) : 콜백에서 Promise 객체를 리턴

콜백이 리턴한 Promise  객체를 B라고 하면 A는 B와 동일한 상태와 결과를 갖게 됩니다. 나중에 B가 fulfilled 상태가 되면 A도 똑같이 fulfilled 상태가 되고 동일한 작업 성공 결과를, 나중에 B가 rejected 상태가 되면 A도 똑같이 rejected 상태가 되고 동일한 작업 실패 정보를 가진다는 뜻입니다.

Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴

A는 fulfilled 상태가 되고, 해당 리턴값을 작업 성공 결과로 갖게 됩니다.

Case(3) : 콜백에서 아무것도 리턴하지 않음

자바스크립트에서는 함수가 아무것도 리턴하지 않으면 undefined를 리턴한 것으로 간주합니다. 
따라서 A는 fulfilled 상태가 되고, undefined를 작업 성공 결과로 갖게 됩니다.

Case(4) : 콜백 실행 중 에러 발생

A는 rejected 상태가 되고, 해당 에러 객체를 작업 실패 정보로 갖게 됩니다.

Case(5) : 콜백이 실행되지 않음

A는 호출된 then 메소드의 주인에 해당하는, 이전 Promise 객체와 동일한 상태와 결과를 가집니다.

Promise 객체 공부는 then 메소드가 그 처음과 끝이라고 해도 될 정도로, then 메소드를 정확하게 이해하는 것이 중요합니다. 지금 각각의 케이스를 잘 기억해 두면, 앞으로의 내용을 훨씬 더 쉽게 이해할 수 있을 겁니다.


Promise 객체는 크게 3가지 중 하나의 상태를 가집니다. 작업이 아직 완료되지 않았으면 pending 상태, 작업이 성공적으로 잘 완료되었다면 fulfilled 상태, 작업이 실패했다면 rejected 상태가 되는데요. 즉, 최초의 pending 상태에서 fulfilled 상태 또는 rejected 상태로 변하는 겁니다. 참고로, pending 상태에서 한번 fulfilled 상태 또는 rejected 상태가 되면 다시 다른 상태를 가질 수 없습니다.

# 문제
만약 인터넷이 안되는 상황에서 아래 코드를 실행한다면 무슨 문자열이 출력될까요?
fetch('https://jsonplaceholder.typicode.com/')
  .then((result) => { console.log('success'); }, (error) => { console.log('fail'); });

인터넷이 안 되는 상태에서는 fetch 함수의 작업이 실패하겠죠? 그럼 fetch 함수가 리턴한 Promise 객체가 rejected 상태가 되고, 이렇게 Promise 객체가 rejected 상태가 되면. then 메소드의 두 번째 콜백이 실행됩니다. 잘 기억하세요!

자바스크립트에서는 함수가 아무것도 리턴하지 않으면, undefined를 리턴한 것으로 봅니다. 따라서 콜백에서 아무것도 리턴하지 않아도 undefined를 리턴한 것으로 보아서, A는 fulfilled 상태가 되고, 작업 성공 결과로 undefined를 갖게 됩니다. Promise Chaining을 완벽하게 이해하려면 then 메소드에 관한 이런 규칙들을 제대로 이해해야 합니다.


#  catch 메소드

fetch('https://jsonplaceholder.typicode.com/')
    .then((result) => response.text(), (error) => { console.log(error); })
    .then((result) => { console.log(result); });

# then 메소드와 catch 메소드의 역할이 동일.
fetch('https://jsonplaceholder.typicode.com/')
    .then((result) => response.text(), 
    .catch((error) => { console.log(error); })
    .then((result) => { console.log(result); });


# catch 메소드를 마지막에 사용
fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => response.json())
    .then((result) => { console.log(result); })
    .catch((error) => { console.log(error); });



# 어디서 발생한 에러인지 확인해보기

    .catch((error) => { 
        if(error.message === 'A'){

        }else if(error.message === 'B'){

        }else if(error.message === 'C'){

        }else{

        }
    });


====
.catch((error) => { 
    if(error instanceof TypeError){

    }else if(error instanceof CustomErrorType_A){

    }else if(error instanceof CustomErrorType_B){

    }else{

    }
});

# catch 메소드를 여러 개 쓰는 경우

우리는 이제 catch 메소드를 Promise Chain 가장 마지막에 붙임으로써, 중간에 에러가 발생해서 어느 Promise 객체가 rejected 상태가 되더라도 항상 대처할 수 있도록 해야 한다는 걸 배웠습니다. 하지만 catch 메소드를 마지막뿐만 아니라 Promise Chain 중간중간에 쓰는 경우도 존재합니다. 만약 중간에 에러가 발생해도 catch 메소드가 그 대안을 뒤로 넘겨줄 수 있으면 catch 메소드를 중간에 써도 되는데요.

아래 코드를 잠깐 봅시다.

fetch('https://friendbook.com/my/newsfeeds')
  .then((response) => response.json()) // -- A
  .then((result) => { // -- B
    const feeds = result;
    // 피드 데이터 가공...
    return processedFeeds; 
  })
  .catch((error) => { // -- C
    // 미리 저장해둔 일반 뉴스를 보여주기  
    const storedGeneralNews = getStoredGeneralNews();
    return storedGeneralNews;
  })
  .then((result) => { /* 화면에 표시 */ }) // -- D
  .catch((error) => { /* 에러 로깅 */ }); // -- E
이 코드는 어떤 SNS 웹 사이트에서 나에게 최적화된 뉴스피드(newsfeed)를 보여주는 코드라고 가정해봅시다. 만약 서버로부터 뉴스피드가 잘 조회되면 현재 코드에서 A, B, D 줄에 있는 콜백들이 잘 실행되고, 사용자에게 뉴스피드가 잘 표시되겠죠? 하지만 만약 사용자의 컴퓨터가 인터넷에 연결되어 있지 않은 상태라서 fetch 함수의 작업이 실패한다면 어떻게 될까요? 그럼 이제 이 Promise Chain의 작업은 실패했다고 생각하고, 이전에 배운 것처럼 그냥 마지막에만 catch 메소드를 두고 끝내면 되는 걸까요? 꼭 그렇지는 않습니다. 만약 작업을 살릴 수 있는 방법이 있다면 살리는 게 좋겠죠?

지금 C줄에 있는 콜백을 보세요. fetch 함수의 작업이 실패하면 C 줄의 콜백이 실행됩니다. 사실, 이 SNS 서비스의 웹 페이지에서는 사용자가 매번 뉴스피드를 볼 때마다, 나중에 오프라인 상태가 될 때를 대비해서 모든 사람이 공통으로 볼 수 있는, 텍스트로만 이루어진 최근 일반 뉴스 데이터를 갱신해서 웹 브라우저에 저장한다고 해봅시다. C줄의 콜백은 바로 이렇게 저장해둔 일반 뉴스 데이터를 그대로 가져오는 기능을 합니다. 이렇게 되면 인터넷이 안 되는 상황에서도 나만을 위한 최적화된 뉴스피드는 못 보지만 일반적인 세상 뉴스는 사용자가 볼 수 있게 되겠죠?

이렇게 Promise Chain 중에서 비록 에러가 발생했다고 해도 만약 실패한 작업 대신 다른 방법을 통해서 작업을 정상적으로 끝마칠 수 있는 상황이라면 catch 메소드를 중간에 사용하기도 합니다. 그러니까 Promise Chain 중에서 단 하나의 작업이라도 실패하면 전체 작업이 실패했다고 봐도 되는 경우에는 그냥 Promise Chain 마지막에만 catch 메소드를 써주면 되겠지만, 어떤 작업들은 에러가 발생하더라도 다른 방식으로 복구해서 살려낼 방법이 있다면 catch 메소드 안의 콜백에서 그런 복구 작업을 해주면 되는 겁니다. 지금 위 코드에서는 미리 저장해둔 일반 뉴스 데이터를 구해오는 getStoredGeneralNews 함수를 실행하는 것처럼요.

catch 메소드를 Promise Chain의 마지막에 늘 써줘야 하는 것은 맞지만, 작업을 살릴 방법이 있다면 Promise Chain 중간에 catch 메소드를 써도 된다는 사실, 잘 기억해두세요.



# finally 메소드
// catch 메소드 이후에 사용한다.

fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => response.text())
    .then((result) => { console.log(result); })
    .catch((error) => { console.log(error); });
    .finally(() => { console.log('exit'); });

// catch method가 return한 Promise 객체를 rejected 함.
.catch((error) => {
    console.log(error); 
    throw new Error('from catch method');
});


#실습 설명

Promise Chain에서 늘 모든 작업이 정상적으로 수행되고 종료되는 것은 아닙니다. 모든 작업이 순차적으로 정상 수행되는 경우도 있고 중간에 문제가 생겨서 그렇지 못하는 경우도 있어요. 이 두 가지 중 어느 경우가 됐든 마지막에 항상 처리해 줘야하는 작업이 있을 때는 finally 메소드를 사용합니다.

지금 코드잇 실행기에는 어떤 웹 페이지의 로딩(loading) 아이콘에 관한 코드가 있습니다. 이 코드에서는 어떤 URL로 리퀘스트를 보내기 전에 isLoading이라는 변수의 값을 true로 설정하고, 로딩 아이콘을 띄운 후에 리퀘스트를 보내는데요.

첫 번째 then 메소드의 콜백을 보면, 리스폰스의 헤드에서 'content-type' 헤더를 찾아 그 값을 읽고 만약 'application/json'이라는 값을 포함하고 있다면 즉, 리스폰스의 바디에 JSON 포맷의 데이터가 들어있다면 이를 Deserialize해서 다음으로 넘깁니다. 하지만 'application/json' 타입이 아니라면 인위적으로 에러를 발생시킵니다.

그런데 어떤 경우든 상관없이 모든 작업이 끝나고 나면, isLoading 변수의 값은 false로 설정해 줘야 합니다. 
왜냐하면 이 isLoading 변수는 현재 사용자의 리퀘스트에 대한 처리가 이루어지고 있고, 로딩 아이콘이 화면에서 나타나있는지 여부를 나타냄으로써, 더 이상 사용자가 마우스를 아무리 클릭해도 리퀘스트를 또 보내는 것을 막고, 그 밖의 다른 작업이 시작되지 못하도록 막아야하는지를 판단하기 위한 기준으로 사용되기 때문입니다. (실무에서는 이런 변수를 사용하는 것 말고 다른 좋은 방법들도 있지만 일단은 간단한 코드로 배워 봅시다.)

어떤 경우든 마지막에 isLoading 변수의 값이 false가 되어야, 이 웹 페이지는 전체 작업의 성공 여부와 상관없이 앞으로도 정상적으로 동작할 수 있는데요. 필요한 코드를 추가해서 어떤 경우든 isLoading 변수의 값을 false로 만들고 그 값을 출력해 보세요.

참고로, 코드 상단의 URL 두 개 중에서 첫 번째는 JSON 데이터가 오는 URL이고, 두 번째는 HTML 등의 코드가 오는 URL입니다.

각 URL 앞의 주석을 번갈아 해제해서 코드를 실행해보고 isLoading 변수가 항상 false가 되는지 확인해 보세요.

let isLoading = true;

/* ..다른 코드들 */

const url = 'https://jsonplaceholder.typicode.com/users';
// const url = 'https://www.google.com';

fetch(url)
  .then((response) => {
    const contentType = response.headers.get('content-type');
    if (contentType.includes('application/json')) {
      return response.json();
    }
    throw new Error('response is not json data');
  })
  .then((result) => {
    // 리스폰스 처리
    console.log(result);
  })
  .catch((error) => {
    // 에러 처리
    console.log(error);
  })
  .finally(() => {
    isLoading = false;
    console.log(isLoading);
  });

/* ..다른 코드들 */


# 변수와 스코프

var x;  //함수 스코프 (function scope)
let y;  //블록 스코프 (block scope)
const z;  //블록 스코프 (block scope)

# 종합 정리
자바스크립트의 데이터 타입
자바스크립트에는 8가지 데이터 타입이 있습니다.

number
string
boolean
undefined
null
object
symbol
bigint
자바스크립트의 유연한 데이터 타입
자바스크립트는 데이터 타입이 유연한 프로그래밍 언어입니다. 맥락에 유연하게 변하는 데이터 타입의 특징은 처음엔 생소하고 혼란스러울 수 있지만, 잘 이해하고 활용한다면 좀 더 간결한 코드를 작성하고 빠르게 개발할 수 있는 장점이 될 수 있습니다!

Truthy 값과 Falsy 값
if, for, while 등 불린 타입의 값이 요구되는 맥락에서는 조건식이나 불린 타입의 값 뿐만아니라 다른 타입의 값도 불린 값처럼 평가될 수 있는데요. 이 때, false 처럼 평가되는 값을 falsy 값, true 처럼 평가되는 값을 truthy값이라고 부릅니다. falsy값에는 false, null, undefined, 0, NaN, ''(빈 문자열)이 있고, falsy값을 제외한 값들은 모두 truthy값이 됩니다.

만약 falsy와 truthy값을 명확하게 확인하고 싶다면 Boolean 함수를 사용해서 직접 boolean 타입으로 형 변환 해볼 수도 있습니다.

// falsy
Boolean(false);
Boolean(null);
Boolean(undefined);
Boolean(0);
Boolean(NaN);
Boolean('');

// truthy
Boolean(true);
Boolean('codeit');
Boolean(123);
Boolean(-123);
Boolean({});
Boolean([]);
truthy와 falsy의 개념은 자바스크립트에서 불린 타입으로의 형 변환을 이해할 때 핵심이되는 개념이 잘 기억해 주세요.

독특한 방식으로 동작하는 논리 연산자
자바스크립트에서 AND와 OR연산자는 무조건 불린 값을 리턴하는게 아니라, 왼쪽 피연산자 값의 유형에 따라서 두 피연산자 중 하나를 리턴하는 방식으로 동작합니다.
AND 연산자는 왼쪽 피연산자가 falsy값일 때 왼쪽 피연산자를, 왼쪽 피연산자가 truthy값일 때 오른쪽 피연산자를 리턴하고 반대로, OR 연산자는 왼쪽 피연산자가 falsy 일 때 오른쪽 피연산자를, 왼쪽 피연산자가 truthy 일 때 왼쪽 피연산자를 리턴합니다.

console.log(null && undefined); // null
console.log(0 || true); // true
console.log('0' && NaN); // NaN
console.log({} || 123); // {}
자바스크립트의 다양한 변수 선언 방식
자바스크립트에는 다양한 변수 선언 키워드가 있습니다. 자바스크립트가 처음 등장할 때부터 사용되던 var와, 그리고 var의 부족함을 채우기위해 ES2015에서 새롭게 등장한 let과 const가 있는데요.

var 변수는 아래와 같은 특징이 있었습니다.

변수 이름 중복선언 가능,
변수 선언 전에 사용 가능(호이스팅),
함수 스코프
특히나 중복된 이름으로 선언이 가능했던 특징은 여러 사람이 협업할 때 생각보다 자주 문제가 되곤 했었는데요. 
이런 문제를 개선하기 위해 ES2015에서 let과 const가 등장했고, 다음과 같은 특징이 있습니다.

변수 이름 중복선언 불가 (SyntaxError 발생)
변수 선언 전에 사용 불가 (ReferenceError 발생)
블록 스코프
덧붙여 const 키워드는 let 키워드와 다르게 값을 재할당할 수 없다는 특징도 있습니다.
그래서 ES2015 이후부터는 var보다 let과 const 키워드 사용이 권장된다는 사실도 참고해 두시면 좋을 것 같습니다.

함수 스코프(function scope)와 블록 스코프(block scope)
var 키워드로 선언한 변수는 함수 스코프 let과 const 키워드로 선언한 변수는 블록 스코프를 가집니다.

함수 스코프란 말 그대로 함수를 기준으로 스코프를 구분한다는 뜻인데요. 그렇기 때문에 아래 코드처럼 함수 안에서 선언한 변수는 함수 안에서만 유효하게 됩니다.

function sayHi() {
  var userName = 'codeit';
  console.log(`Hi ${userName}!`);
}

console.log(userName); // ReferenceError
하지만 함수를 제외한 for, if, while 등과 같은 문법 안에서 선언한 변수는 그 문법 밖에서도 계속 유효했었기 때문에 때로는 중복선언등의 문제가 생겨나기도 했는데요.
이런 문제를 해결하기 위해 let과 const 키워드와 함께 블록 스코프가 등장하게 된 겁니다.

for (var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // 5
블록 스코프는 중괄호로 감싸진 코드 블록에 따라 유효 범위를 구분하게 되는데요. 아래 코드에서 볼 수 있듯이 함수와 다른 문법들 뿐만아니라, 그냥 중괄호로 감싸진 코드 블록으로도 유효 범위가 구분되는 모습을 확인할 수 있습니다.

function sayHi() {
  const userName = 'codeit';
  console.log(`Hi ${userName}!`);
}

for (let i = 0; i < 5; i++) {
  console.log(i);
}

{
  let language = 'JavaScript';
}

console.log(userName); // ReferenceError
console.log(i); // ReferenceError
console.log(language); // ReferenceError

# 함수를 만드는 방법
function 함수이름(파라미터) {
    동작;
    return 리턴값;
}
함수 호출;

# 함수를 변수에 할당 하는 방법
const printCodeit = function () {
    console.log('Codeit');
};

printCodeit();


// 함수에 할당하는 방법은 호이스팅이 불가하다. 에러발생

printCodeit();

const printCodeit = function () {
    console.log('Codeit');
};


# 함수호출을 위쪽으로 끌어 올리는 방법을 호이스팅(Hoisting)

printCodeit();

function printCodeit() {
    console.log('Codeit');
};



# 이름이 있는 함수 표현식
Named Function Expression (기명 함수 표현식)
함수 표현식으로 함수를 만들 때는 선언하는 함수에 이름을 붙여줄 수도 있는데요.
이름이 있는 함수 표현식, 즉 기명 함수 표현식이라고 부릅니다.
함수 표현식으로 함수가 할당된 변수에는 자동으로 name이라는 프로퍼티를 가지게 되는데요.

const sayHi = function () {
  console.log('Hi');
};

console.log(sayHi.name); // sayHi
이렇게 이름이 없는 함수를 변수에 할당할 때는 변수의 name 프로퍼티는 변수 이름 그 자체를 문자열로 가지게 됩니다. 하지만 함수에 이름을 붙여주게 되면, name 속성은 함수 이름을 문자열로 갖게 되는데요.

const sayHi = function printHiInConsole() {
  console.log('Hi');
};

console.log(sayHi.name); // printHiInConsole
이 함수 이름은 함수 내부에서 함수 자체를 가리킬 때 사용할 수 있고 함수를 외부에서 함수를 호출할 때 사용할 수는 없습니다.

const sayHi = function printHiInConsole() {
  console.log('Hi');
};

printHiInConsole(); // ReferenceError
기명 함수 표현식은 일반적으로 함수 내부에서 함수 자체를 가리킬 때 사용되는데요. 아래 코드를 살펴봅시다.

let countdown = function(n) {
  console.log(n);

  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

countdown(5);
아규먼트로 숫자 값을 전달하고 전달받은 그 값이 0이 될 때까지 하나씩 값을 줄이면서 자기 자신을 호출하는 countdown이라는 함수를 함수 표현식으로 작성해봤는데요. 이런 식으로 자기 자신을 부르는 함수를 재귀 함수(Recursive function)라고 부릅니다.
그런데 만약 이 함수를 복사하려고 다른 변수에 똑같이 담았다가, countdown 변수에 담긴 값이 변하게 되면 문제가 발생하는데요.

let countdown = function(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

let myFunction = countdown;

countdown = null;

myFunction(5); // TypeError
에러코드실행화면

마지막 줄에서 myFunction 함수를 호출했을 때, 함수가 실행되긴 하지만, 6번줄 동작을 수행할 때 호출하려는 countdown 함수가 이미 12번에서 null 값으로 변경되었기 때문에 함수가 아니라는 TypeError가 발생한 것이죠!
이런 상황을 방지하기 위해서 함수 내부에서 함수 자신을 사용하려고 하면 함수표현식에서는 반드시 기명 함수 표현식을 사용하는 것이 좋습니다.

let countdown = function printCountdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    printCountdown(n - 1);
  }
};

let myFunction = countdown;

countdown = null;

myFunction(5); // 정상적으로 동작
정상코드실행화면

함수 표현식을 작성할 때, 함수에 이름을 지정할 수 있다는 점과 특히 이렇게 함수 내에서 함수를 가리켜야 할 때는 꼭 함수 이름을 작성해주는 것이 안전하다는 점. 잘 기억해 두시면 좋을 것 같습니다.



# 즉시 실행 함수 (IIFE)

지금까지 함수를 선언하는 다양한 방법에 대해 살펴봤는데요.
함수를 선언하는 것은 함수를 실행하는 것과 다르다는 사실, 모두 알고 계시죠?

function sayHi() {
  console.log('Hi!');
}
  
sayHi();
일반적으로는 이렇게 함수를 먼저 선언한 다음,선언된 함수 이름 뒤에 소괄호를 붙여서 함수를 실행하는데요.
그런데 때로는 함수가 선언된 순간에 바로 실행을 할 수도 있습니다.

즉시 실행 함수
(function () {
  console.log('Hi!');
})();
보시는 것처럼 함수선언 부분을 소괄호로 감싼 다음에 바로 뒤에 함수를 실행하는 소괄호를 한 번 더 붙여주는 방식인데요.
이렇게 하면 함수가 선언된 순간 바로 실행이 되는 겁니다.

이렇게 함수 선언과 동시에 즉시 실행되는 함수를 가리켜 즉시 실행 함수 (표현)이라고 부르는데요.
영어로는 Immediately Invoked Function Expression, 줄여서 IIFE라고 부릅니다.

(function (x, y) {
  console.log(x + y);
})(3, 5);
그리고 즉시 실행 함수도 일반 함수처럼 파라미터를 작성하고, 함수를 호출할 때 아규먼트를 전달할 수도 있는데요.
한 가지 주의할 점은 즉시 실행 함수는 함수에 이름을 지어주더라도 외부에서 재사용할 수 없다는 겁니다.

(function sayHi() {
  console.log('Hi!');
})();

sayHi(); // ReferenceError
그래서 일반적으로는 이름이 없는 익명 함수를 사용하는데요.
다만, 이름이 있는 함수 표현식 레슨에서도 살펴봤던 것처럼 함수 내부에서 자기 자신을 호출하는 재귀적인 구조를 만들고자 할 땐 이름이 필요할 수도 있으니까 이 부분은 참고해 주세요!

(function countdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
})(5);
즉시 실행 함수의 활용
즉시 실행 함수는 말 그대로 선언과 동시에 실행이 이뤄지기 때문에 일반적으로 프로그램 초기화 기능에 많이 활용됩니다.

(function init() {
  // 프로그램이 실행 될 때 기본적으로 동작할 코드들..
})();
혹은 재사용이 필요 없는, 일회성 동작을 구성할 때 활용하기도 하는데요.

const firstName = 'Young';
const lastName = 'Kang';

const greetingMessage = (function () {
  const fullName = `${firstName} ${lastName} `;

  return `Hi! My name is ${fullName}`;
})();
이렇게 함수의 리턴값을 바로 변수에 할당하고 싶을 때 활용할 수 있습니다.

그리고, 전역변수와 지역변수의 개념 알고 계시죠?
즉시 실행 함수에서 사용하는 변수들은 함수 내에서만 유효하기 때문에 이런 점을 활용하면, 일시적으로 사용할 변수의 이름들을 조금 자유롭게 작성할 수도 있다는 점. 잘 기억해 두세요!

# 고차 함수 (Higher Order Function)
function getPrintHi() {
    return function () {
        console.log('Hi!?');
    };
};
const sayHi = getPrintHi();

sayHi();

=== 바로 호출도 가능
getPrintHi()();

// = 일급 함수(First Class Function)


# Parameter

function greeting(name) {
    console.log('Hi! My name is ${name}!');
}

greeting('JavaScript');


# 아규먼트(argument)

function greeting(파라미터) {
    console.log('Hi! My name is ${name}!');
}

greeting('아규먼트');

// 파라미터가 있는 함수를 호출할 때 빈 아규먼트를 호출하게 되면 undefined를 호출한다.
greeting(); 

# 파라미터 값을 지정하면 파라미터 값을 호출한다.

function greeting(name = 'Codeit') {
    console.log('Hi! My name is ${name}!');
}
greeting();
// Hi! My name is Codeit!

# 파라미터 값을 지정하게 되면 우측 마지막에 작성을 한다. 그렇지 않으면 undefined가 호출됨.
# function greeting(interest, name = 'Codeit')
function greeting(name = 'Codeit', interest) {
    console.log('Hi! My name is ${name}!');
    console.log('I like ${interest}!');
}
greeting();
// Hi! My name is Codeit!
// I like undefined!



function greeting(interest, name = 'Codeit') {
    console.log('Hi! My name is ${name}!');
    console.log('I like ${interest}!');
}

greeting('Java');


# Arguments
// 함수에 for문을 이용해서 아규먼트를 불러 올수 있다.
# 변수로 argument 사용을 해서는 안된다.
function printArguments(a, b, c) {
    for (const arg of arguments) {
        console.log(arg);
    }
    console.log{'--------------'};
};

printArguments('tony', 'Mark', 'Koby');
printArguments('Captain');
printArguments('suri', 'kack', 'joy', 'noel');


# Rest Parameter
// 다수의 파라미터를 사용할 경우 가장 마지막에 사용.(first, second, ...args)
function printArguments(...args) {
    for (const arg of args) {
        console.log(arg);
    }
    console.log{'--------------'};
};

# splice method
function printArguments(...args) {
    console.log(args.splice(0, 2));
    console.log(arguments.splice(0, 2));
    console.log{'--------------'};
};


# 실습 설명
유튜브나 블로그에서 새로운 전자제품을 리뷰하는 콘텐츠를 보면 우스갯소리로 1세대는 거르는게 답이다.라는 말을 심심찮게 들을 수 있습니다.
그동안 새로운 버전으로 출시되는 제품들은 대부분 잔고장이나 버그들이 많았기 때문인데요.

rest parameter를 활용해서 함수를 호출할 때 여러 개의 아규먼트를 전달할 경우 첫 번째 아규먼트는 무시하고 두 번째 아규먼트 부터 하나씩 콘솔에 출력하는 ignoreFirst 함수를 완성해 주세요!

2세대
3세대
강아지
고양이
9
18
19
30
34
40
# 해설
일단 당장 주어진 코드를 보면, 함수 선언 부분은 없고 ignoreFirst함수를 호출만 3번 하고 있습니다. 함수를 호출할 때 아규먼트는 문자열이기도하고 숫자이고 한데요. 전달하는 값의 개수도 모두 제각각 입니다. 이런 상황에서 rest parameter를 어떻게 활용하면 좋을까요?

이번 과제는 생각보다 간단하게 해결할 수 있는데요. 심지어 해결하는 방법도 다양합니다. 이번 해설에서는 두 가지 정도로 다뤄볼텐데요.

일단 첫 번째는 rest parameter가 arguments 객체와는 다르게 배열이라는 점을 응용하는 겁니다. 그래서 아규먼트로 전달하는 값들 중 가장 첫 번째를 제외한 값들을 콘솔에 출력해야 하니, 가장 첫 요소를 제거해 주는 배열의 shift 메소드를 활용하는 방식인데요. shift 메소드로 첫 요소를 제거한 다음 for of문을 통해 각 요소를 콘솔에 출력하면 다음과 같이 작성할 수 있습니다.

// 여기에 코드를 작성하세요
function ignoreFirst(...rest) {
  rest.shift();

  for (const el of rest) {
    console.log(el);
  }
}

ignoreFirst('1세대', '2세대', '3세대');
ignoreFirst('곰팡이', '강아지', '고양이');
ignoreFirst(20, 9, 18, 19, 30, 34, 40);
두 번째 방법은 rest parameter를 일반 파라미터와 함께 사용할 때의 특징을 활용하는 건데요. 일반 파라미터와 함께 사용할 때는 항상 가장 오른편에 작성해야 한다는 점 모두 알고계시죠? 함수를 호출할 때 전달하는 아규먼트들은 앞쪽에 선언된 일반 파라미터에 먼저 할당되고, 나머지 값들이 rest parameter에 배열로 모이는 특징을 활용해서 파라미터 하나를 먼저 선언해 두고 두 번째 파라미터를 rest parater로 작성해서 for of문을 활용하면 다음과 같이 작성할 수 있습니다.

// 여기에 코드를 작성하세요
function ignoreFirst(first, ...rest) {
  for (const el of rest) {
    console.log(el);
  }
}

ignoreFirst('1세대', '2세대', '3세대');
ignoreFirst('곰팡이', '강아지', '고양이');
ignoreFirst(20, 9, 18, 19, 30, 34, 40);
이 밖에도 다양한 방법으로 해결해 볼 수 있을 것 같은데요. rest parameter의 특징을 잘 활용해서 또 어떤 방식을 활용하면 좋을지 여러분도 한번 고민해 보세요!

// 여기에 코드를 작성하세요
function ignoreFirst(...rest) {
  rest.shift();
  
  for (const arg of rest) {
    console.log(arg);
  }
}


ignoreFirst('1세대', '2세대', '3세대');
ignoreFirst('곰팡이', '강아지', '고양이');
ignoreFirst(20, 9, 18, 19, 30, 34, 40);




# 실습 설명
겉바속촉(겉은 바삭하고 속은 촉촉한), 아바라(아이스 바닐라 라떼), 얼죽아(얼어 죽어도 아이스), 별다줄 (별걸 다 줄인다) 등 우리 일상생활에 여러 단어가 조합된 단어를 앞 글자만 따서 다시 한번 더 줄여쓴 줄임말들이 넘쳐나고 있는데요.
arguments 객체를 활용해서 함수를 호출할 때 전달하는 단어들의 첫 글자만 따서 줄임말을 만들어주는 firstWords 함수를 완성해 주세요.

실습 결과
코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

나없고
아바라
만반잘부
결자해지
빨주노초파남보

# 작성
function firstWords() {
  let word = '';

  for(const arg of arguments) {
    word += arg[0];
  }

  console.log(word);
}

firstWords('나만', '없어', '고양이');
firstWords('아니', '바나나말고', '라면먹어');
firstWords('만두', '반으로', '잘라먹네', '부지런하다');
firstWords('결국', '자바스크립트가', '해피한', '지름길');
firstWords('빨간색', '주황색', '노란색', '초록색', '파란색', '남색', '보라색');



# 태그 이름으로 태그 선택하기

지금까지 id와 class 속성을 이용해서 JavaScript로 HTML 태그를 선택하는 방법에 대해 알아봤는데요.
document.getElementsByTagName('태그이름')메소드를 활용하면 태그 이름으로 태그를 선택할 수 있습니다.

const btns = document.getElementsByTagName('button');

이렇게 하면 HTML 문서 내에 있는 모든 button 태그를 선택하게 됩니다.

태그이름으로태그선택하기

document.getElementsByClassName('class')메소드와 마찬가지로 태그 이름으로 요소를 찾는 경우에 여러 개의 요소가 선택될 수 있기 때문에 메소드 이름에 Element(s), s가 있고, 실행결과 역시 HTMLCollection을 리턴한다는 점도 함께 기억해 두시면 좋을 것 같습니다.

참고로 css 선택자처럼 '*' 값을 전달하게 되면 모든 태그를 선택할 수도 있는데요.

const btns = document.getElementsByTagName('button');
const allTags = document.getElementsByTagName('*');
하지만, css 스타일링을 할 때도 태그 이름으로 스타일링을 하는 경우는 거의 없죠?

마찬가지로 명확한 의도가 없이 이렇게 많은 요소들을 한꺼번에 다루게 되면 예상치 못한 실수를 할 가능성이 있기 때문에 자바스크립트에서도 많이 사용되는 메소드는 아닙니다.


# Arrow Function
# 1
const getTwice = function(number) {
    return number * 2;
};

console.log(getTwice(6));

# 2
function getTwice(number) {
    return number * 2;
}
console.log(getTwice(6));


# 3
const getTwice = number => number * 2;

console.log(getTwice(6));

# 4
const getTwice = (a, b) => {
    const result = a + b;
    return result;
};

console.log(getTwice(6, 7));

# 5 Arrow Function으로 변환하기
const getObject = function(a, b, c) {
  return { 0: a, 1: b, 3: c };
}

// const getObject = (a, b, c) => ({ 0: a, 1: b, 3: c });
기존의 함수 선언 방식을 화살표 함수로 변환하면 몇 가지 조건에 따라 축약된 표현들을 사용할 수가 있는데요.

파라미터가 하나일 때 파라미터를 감싸는 소괄호 부분을 생략할 수 있습니다. 하지만, 주어진 문제의 함수는 파라미터가 3개이기 때문에 소괄호를 생략할 수는 없겠죠?

여기서 한 가지 주의해야 할 부분이 있습니다. 함수 내부의 동작이 return 문 하나밖에 없지만 return 값이 객체일 때 무작정 중괄호를 생략해 버리면, 객체를 표현하는 중괄호를 함수의 동작 부분을 구분하는 중괄호로 해석해 버려서 오류가 발생하기 때문입니다. 
그래서 이런 경우에는 객체를 표현하는 중괄호 바깥에 소괄호를 한 번 더 감싸주어야 한다.

# this

function getFullName() {
    return '${this.firstName} ${this.lastName}';
}

const user = {
    firstName: 'Tess'.
    lastName: 'Jang',
    getFullName: getFullName,
};

const admin = {
    firstName: 'Alex'.
    lastName: 'Kim',
    getFullName: getFullName,
};

console.log(user.getFullName());
console.log(admin.getFullName());

# 종합 정리
함수 선언
자바스크립트에서 함수는 다양한 방식으로 선언할 수 있습니다.
가장 일반적인 방법은 function 키워드를 통해 함수를 선언하는 방식인데요.

// 함수 선언
function sayHi() {
  console.log('Hi!');
}
이렇게 작성하는 방식을 함수 선언(function declaration)이라고 합니다.

함수 표현식
그리고 자바스크립트에서 함수는 값으로 취급될 수도 있기 때문에 변수에 할당해서 함수를 선언할 수도 있습니다.

// 함수 표현식
const sayHi = function () {
  console.log('Hi!');
};
이렇게 함수를 값으로 다루는 방식을 함수 표현식 (function expression)이라고 합니다.

다양한 함수의 형태
자바스크립트에서 함수는 값으로 취급되는데요. 이런 특징은 코드를 작성할 때 다양한 형태로 활용될 수 있습니다.

// 변수에 할당해서 활용
const printJS = function () {
  console.log('JavaScript');
};

// 객체의 메소드로 활용
const codeit = {
  printTitle: function () {
    console.log('Codeit');
  }
}

// 콜백 함수로 활용
myBtn.addEventListener('click', function () {
  console.log('button is clicked!');
});

// 고차 함수로 활용
function myFunction() {
  return function () {
    console.log('Hi!?');
  };
};
파라미터의 기본값
자바스립트에서 함수의 파라미터는 기본값을 가질 수가 있는데요. 기본값이 있는 파라미터는 함수를 호출할 때 아규먼트를 전달하지 않으면, 함수 내부의 동작은 이 파라미터의 기본값을 가지고 동작하게 됩니다.

function sayHi(name = 'Codeit') {
  console.log(`Hi! ${name}`);
}

sayHi('JavaScript'); // Hi! JavaScript
sayHi(); // Hi! Codeit
arguments 객체
자바스크립트 함수 안에는 arguments라는 독특한 객체가 존재합니다.
arguments 객체는 함수를 호출할 때 전달한 아규먼트들을 배열의 형태로 모아둔 유사 배열 객체인데요. 특히, 함수를 호출할 때 전달되는 아규먼트의 개수가 불규칙적일 때 유용하게 활용될 수 있습니다.

function printArguments() {
  // arguments 객체의 요소들을 하나씩 출력
  for (const arg of arguments) {
    console.log(arg); 
  }
}

printArguments('Young', 'Mark', 'Koby');
참고로 arguments라는 객체를 활용하고자 한다면 함수 안에서 사용할 파라미터나 변수, 함수의 이름을 arguments라고 짓는 것은 피하는게 좋겠죠?

Rest Parameter
arguments 객체를 이용하는 것 말고도 불규칙적으로 전달되는 아규먼트를 다루는 방법이 있는데요. 파라미터 앞에 마침표 세 개를 붙여주면, 여러 개로 전달되는 아규먼트들을 배열로 다룰 수가 있게 됩니다.
그리고 arguments객체는 유사 배열이기 때문에 배열의 메소드를 활용할 수 없는 반면, rest parameter는 배열이기 때문에 배열의 메소드를 자유롭게 사용할 수 있다는 장점이 있습니다.

function printArguments(...args) {
  // args 객체의 요소들을 하나씩 출력
  for (const arg of args) {
    console.log(arg); 
  }
}

printArguments('Young', 'Mark', 'Koby');
rest parameter는 다른 일반 파라미터들과 함께 사용될 수도 있는데요.

function printRankingList(first, second, ...others) {
  console.log('코드잇 레이스 최종 결과');
  console.log(`우승: ${first}`);
  console.log(`준우승: ${second}`);
  for (const arg of others) {
    console.log(`참가자: ${arg}`);
  }
}

printRankingList('Tommy', 'Jerry', 'Suri', 'Sunny', 'Jack');
이름 그대로 앞에 정의된 이름 그대로 앞에 정의된 파라미터에 argument를 먼저 할당하고 나머지 argument를 배열로 묶는 역할을 하기 때문에 일반 파라미터와 함께 사용할 때는 반드시 가장 마지막에 작성해야 한다는 점을 꼭 기억해 주세요!

Arrow Function
arrow function은 익명 함수를 좀 더 간결하게 표현할 수 있도록 ES2015에서 새롭게 등장한 함수 선언 방식입니다.
아래 코드와 같이 표현식으로 함수를 정의할 때 활용될 수도 있고 콜백 함수로 전달할 때 활용할 수도 있습니다.

// 화살표 함수 정의
const getTwice = (number) => {
  return number * 2;
};

// 콜백 함수로 활용
myBtn.addEventListener('click', () => {
  console.log('button is clicked!');
});
화살표 함수는 다양한 상황에 따라 축약형으로 작성될 수 있는데요.
아래 코드와 주석을 한 번 참고해 주세요!

// 1. 함수의 파라미터가 하나 뿐일 때
const getTwice = (number) => {
  return number * 2;
};

// 파라미터를 감싸는 소괄호 생략 가능
const getTwice = number => {
  return number * 2;
};

// 2. 함수 동작 부분이 return문만 있을 때
const sum = (a, b) => {
  return a + b;
};

// return문과 중괄호 생략 가능
const sum = (a, b) => a + b;



그리고 Arrow function이 일반 함수와 몇 가지 차이점이 있는데요.
가장 대표적인 차이점은 arguments 객체가 없고, this가 가리키는 값이 일반 함수와 다르다는 점입니다.
arrow function을 사용할 땐 이런 부분을 잘 고려해야 된다는 점을 잊지 마세요!

this
자바스크립트에는 this라는 조금 특별한 키워드가 있습니다.
웹 브라우저에서 this가 사용될 때는 전역 객체, Window 객체를 가지게 됩니다. 하지만 객체의 메소드를 정의하기 위한 함수 안에선 메소드를 호출한 객체를 가리키게 됩니다.

const user = {
  firstName: 'Tess',
  lastName: 'Jang',
  getFullName: function () {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(user.getFullName()); // getFullName 안에서의 this는 getFullName을 호출한 user객체가 담긴다!



# Promise 객체는 왜 등장했을까?

이때까지 우리는 Promise Chaining, then/catch/finally 메소드 등 Promise 객체에 관한 많은 것들을 배웠습니다. 그런데 여기서 궁금한 점이 하나 있습니다. Promise 객체는 왜 등장한 걸까요?

사실 Promise 객체가 등장하기 전에도 비동기적인 처리를 할 수 있는 방법은 있었습니다. 
이전 노트에서 배운 setTimeout 함수나, addEventListener 메소드처럼요.

setTimeout(callback, milliseconds);
addEventListener(eventname, callback);
이것들은 모두 직접 파라미터에 콜백을 전달하는 형식으로 정의되어 있는데요. 만약 fetch 함수를 이런 식으로 만들었다면

fetch('https://first.com', callback)
fetch 함수도 이런 식으로 사용했었겠죠? 그런데 왜 이런 방법이 선택되지 않고, 굳이 Promise 객체라는 문법이 도입된 것일까요? 
그 이유는 바로 함수에 콜백을 직접 넣는 형식은 콜백 헬(callback hell)이라고 하는 문제를 일으킬 수도 있기 때문입니다.

잠깐 이 코드를 봅시다. 만약 fetch 함수가 지금과 같이 Promise 객체를 리턴하는 게 아니라 setTimeout 함수처럼 콜백을 직접 집어넣는 형식의 함수였다면 우리는 여러 비동기 작업을 순차적으로 수행해야할 때

fetch('https://first.com', (response) => {
  // Do Something
  fetch('https://second.com', (response) => {
    // Do Something
    fetch('https;//third.com', (response) => {
      // Do Something
      fetch('https;//fourth.com', (response) => {
        // Do Something
      });
    });
  });
});
이런 식의 코드를 작성해야 했을 겁니다. 지금 fetch 함수 안의 콜백에 fetch 함수가 있고 그 함수의 콜백 안에 fetch 함수가 있고 또.. 계속 이런 식으로 들어가있죠? 그런데 이 코드를 보면 어떤 느낌이 드시나요? 뭔가 읽기 어렵고 복잡해 보이죠? 한마디로 가독성이 떨어집니다. 그나마 지금은 실제 코드가 들어가야 할 자리에 "// Do Something" 이라는 주석이 들어가 있어서 괜찮지만, 실제로 필요한 코드들까지 들어가게 되면 이 코드의 가독성은 현저하게 떨어지게 되는데요. 이런 현상을 콜백 지옥 또는 콜백 헬(callback hell)이라고 합니다. 또는 지옥의 피라미드(Pyramid of Doom)라고도 합니다.

하지만 우리가 배웠던 대로 fetch 함수는 Promise 객체를 리턴하기 때문에

fetch('https://first.com')
  .then((response) => {
    // Do Something 
    return fetch('https://second.com');
  })
  .then((response) => {
    // Do Something 
    return fetch('https://third.com');
  })
  .then((response) => { 
    // Do Something 
    return fetch('https://third.com');
  });
이런 식으로 Promise Chaining을 해서 좀 더 깔끔한 코드로 여러 비동기 작업을 순차적으로 처리할 수 있는데요. 
이렇게 Promise 객체를 사용하면 callback hell 문제를 해결할 수 있습니다.

이 뿐만 아니라 기존에 콜백을 직접 넣는 방식에 비해 Promise 객체의 문법은 비동기 작업에 관한 좀 더 세밀한 개념들이 반영되어 있습니다. 이전의 방식에서는 콜백에 필요한 인자를 넣어주고 실행하면 되는 단순한 방식이었다면, Promise 객체 문법에는 pending, fulfilled, rejected 상태, 작업 성공 결과 및 작업 실패 정보(이유), then, catch, finally 메소드 등과 같은 비동기 작업에 관한 보다 정교한 설계가 문법 자체에 반영되어 있다는 것을 알 수 있습니다.

바로 이렇게 Promise 객체라는 개념은,

(1) callback hell 문제를 해결하고, 이에 더해서 
(2) 비동기 작업 처리에 관한 좀 더 세밀한 처리를 자바스크립트 문법 단에서 해결하기 위해 등장했고,

그 유명한 자바스크립트의 2015년도 표준인 ES6(=ES2015)에 추가되었습니다.

오늘날 Promise는 자바스크립트 비동기 실행에 있어서 아주 핵심적인 문법입니다.



# Promise Chaining

function removeUnnecessaryInfo(users) {
  const processedUserList= users.map((user) => {
    const keys = Object.keys(user);
    const processedUser = {};
    keys.forEach((key) => {
      if (key === 'name' || key === 'email') {
        processedUser[key] = user[key];
      }
    });
    return processedUser;
  });
  const p = new Promise((resolve) => {
    setTimeout(() => { resolve(processedUserList); }, 1000); 
  });
  return p;
}

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.json())
  .then((result) => removeUnnecessaryInfo(result))
  .then((result) => {
    console.log(result);
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    console.log('This job will be done by server soon!');
  });



Promise Chaining을 할 때는 아래와 같은 순서로 진행합니다.

(1) 각 비동기 작업을 순차적으로 처리하기 위해서 실행할 콜백들을 then 메소드들로 앞에서 설정한다. 
(2) catch 메소드를 사용한다. (Error 발생으로 인해 어느 Promise 객체가 rejected 상태가 되더라도 대응)
(3) finally 메소드를 사용한다. (전체 작업이 성공하거나 중간에 실패하거나, 심지어 catch 메소드의 콜백에서 에러가 발생하는 경우에도 항상 실행해야 할 콜백을 등록)

Promise Chain에서 각 메소드의 전형적인 등장 순서를 잘 기억해 주세요.



# 직접 만들어보는 Promise 객체
//Promisify 파일을 만들때만 사용함.
const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve('success'); }, 2000); 
});

p.then((result) => { console.log(result); });


#
const p = new Promise((resolve, reject) => {
    setTimeout(() => { reject new Error('fail'); }, 2000); 
});
p.catch((error) => { console.log(error); });


#
const p = new Promise((resolve) => {
    setTimeout(() => { resolve(processedUserList); }, 1000); 
});
    return p;
}



# Promisify
 직접 Promise 객체를 만드는 방법을 배웠습니다. 그럼 언제 이런 식으로 Promise 객체를 직접 만들게 되는 걸까요? 다양한 경우들이 있지만, 전통적인 형식의 비동기 실행 함수를 사용하는 코드를, Promise 기반의 코드로 변환하기 위해 Promise 객체를 직접 만드는 경우가 많습니다. 각각의 예시를 통해 이게 무슨 말인지 이해해봅시다.

1. setTimeout 함수 예시
예를 들어 이런 wait이라는 함수가 있다고 합시다.

function wait(text, milliseconds) {
  setTimeout(() => text, milliseconds);
}
wait 함수는 특정 밀리세컨즈만큼 시간이 지난 후에 text 파라미터로 전달받은 값을 리턴하는 함수입니다. 지금 보이는 setTimeout 함수는 이전에 [알아야하는 비동기 실행 함수들] 노트에서 배웠었죠? 이 wait 함수를 Promise Chaining 코드에서 사용해볼게요.

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.text())
  .then((result) => { console.log(result); });
바로 이 Promise Chaining 코드에 wait 함수를 추가해볼 건데요. 이렇게 써보겠습니다.

function wait(text, milliseconds) {
  setTimeout(() => text, milliseconds);
}

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.text())
  .then((result) => wait(`${result} by Codeit`, 2000)) // 2초 후에 리스폰스의 내용 뒤에 'by Codeit' 추가하고 리턴
  .then((result) => { console.log(result); });
기존 코드에 두 번째 then 메소드를 추가하고, 그 안에서 wait 함수를 호출했습니다. 이렇게 쓰면 2초 후에 리스폰스의 내용 뒤에 by Codeit이라는 문구를 붙여서 출력될 것 같은데요. 정말 그렇게 되는지 확인해봅시다.

코드를 실행해보면,

jo6wlcosl-Untitled.png

리스폰스의 내용과 by Codeit이 출력되지 않았습니다. 그 대신 undefined가 출력되었는데요.

왜 그런 걸까요? 
그 이유는 바로 wait 함수에 있습니다.

function wait(text, milliseconds) {
  setTimeout(() => text, milliseconds);
}
이 wait 함수는 내부에서 setTimeout 함수를 호출합니다. 그리고 setTimeout 함수의 첫 번째 파라미터로 들어간 콜백이 2초 후에 text를 리턴하죠. 그런데 여기서 혼동하면 안 되는 것은 wait 함수가

...
  .then((result) => { return wait(`${result} by Codeit`, 2000); })
...
이 두 번째 then 메소드 안의 콜백에서 실행될 때,

wait 함수는 setTimeout 함수를 실행할 뿐 아무것도 리턴하지 않는다는 사실입니다. 
setTimeout 함수 안의 콜백이 2초 후에 리턴하는 text는, wait 함수의 리턴값이 아닙니다.

이 사실에 유의해야 하는데요. wait 함수는 단지 setTimeout 함수를 실행하고 아무것도 리턴하지 않는 함수일 뿐입니다. 그리고 자바스크립트에서는 이전에 배운대로 함수에서 아무것도 리턴하지 않으면 undefined를 리턴하는 것으로 간주하기 때문에 wait 함수의 리턴값은 undefined입니다.

따라서 세 번째 then 메소드의 콜백으로 undefined가 넘어가고, 그래서 위 이미지에서 보이는 것처럼 undefined가 출력된 겁니다.

setTimeout은 비동기 실행되는 함수인데요. Promise Chaining 안에서 이렇게 비동기 실행되는 함수를 바로 사용하면, 나중에 실행되는 부분의 리턴값(여기서는 text)를 Promise Chain에서 사용할 수 없게 됩니다.

이 문제를 해결하려면 이전 영상에서 배웠던 Promise 객체를 직접 생성하는 방법을 사용하면 됩니다. wait 함수를 이렇게 수정해볼게요.

// function wait(text, milliseconds) {
//   setTimeout(() => text, milliseconds);
// }

function wait(text, milliseconds) {
  const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve(text); }, 2000);
  });
  return p;
}
지금 wait 함수 안에서 Promise 객체를 직접 생성했고, executor 함수 안에서 setTimeout 함수를 호출했습니다. 그리고 setTimeout 함수 안의 콜백에서 resolve 함수를 호출하는데 이 때 그 아규먼트로 text를 넣었습니다. 그렇다면 Promise 객체 p는 2초 후에 fulfilled 상태가 될 것이고, 그 작업 성공 결과는 파라미터 text의 값이 될 될 것입니다. wait 함수는 이제 Promise 객체 p를 리턴합니다.

자, 이 상태에서 코드를 다시 실행해보면

function wait(text, milliseconds) {
  const p = new Promise((resolve, reject) => {
    setTimeout(() => { resolve(text); }, 2000);
  });
  return p;
}

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => response.text())
  .then((result) => wait(`${result} by Codeit`, 2000)) // 2초 후에 리스폰스의 내용 뒤에 'by Codeit' 추가하고 리턴
  .then((result) => { console.log(result); });
fbmbi7m6k-Untitled 1.png

이번에는 약 2초 후에 리스폰스의 내용이 잘 출력되고,

5d9bljl8g-Untitled 2.png

리스폰스의 내용 맨 마지막에는 by Codeit이라는 문구가 잘 붙어서 출력되는 것을 알 수 있습니다.

방금처럼 기존의 비동기 실행 함수(여기서는 setTimeout)의 콜백이 리턴하는 값을 Promise Chain에서 사용하고 싶다면, 해당 함수를 감싸서 Promise 객체를 직접 생성하는 코드를 작성해야 합니다. 그리고 그 Promise 객체를 리턴해야 방금처럼 Promise Chain에서 해당 리턴값을 받아서 사용할 수 있습니다.

이렇게 전통적인 형식의 비동기 실행 함수를 Promise 객체로 감싸서 그 Promise 객체를 리턴하는 형식으로 만드는 작업을 Promisify(프로미스화하다)라고 하는데요. 앞으로도 이 Promisify라는 용어를 사용하겠습니다. 계속 내용을 읽어봅시다.

2. 콜백 헬(callback hell)과 Promise
이번에는 Promisify의 또 다른 예시를 보겠습니다. 그런데 이번에는 브라우저가 아니라 조금 다른 환경에서의 코드를 볼 건데요. 바로 Node.js라고 하는 환경입니다. 오늘날 자바스크립트가 실행되는 환경에는 웹 브라우저뿐만 아니라 Node.js라고 하는 것도 있습니다. 이 Node.js는 오늘날 자바스크립트를 서버에서도 실행할 수 있게 해주는 또 다른 '자바스크립트 실행 환경'인데요. 이 Node.js에서는 브라우저에서와는 또 다른 비동기 함수들이 제공됩니다. (Node.js가 뭔지 더 궁금하신 분들은 [Node.js가 무엇인가요?] 영상을 참고하세요.)

Node.js에는 다음과 같이 특정 파일의 내용을 읽기 위해 사용되는 readFile이라는 비동기 실행 메소드가 있습니다.

fs.readFile('file1.txt', 'utf8', (error, data) => {
  if (err) {
    console.log(err);
  } else {
    console.log(data);
  }
});
여기서 fs는 readFile 메소드를 가진 객체로, 파일에 관한 기능들을 갖고 있습니다. 일단 여기서 당장 중요한 내용은 아니니까 readFile 메소드에만 집중합시다. readFile 메소드는 첫 번째 파라미터로 파일의 이름, 두 번째 파라미터로 파일 해석 기준(인코딩 기준), 세 번째 파라미터로 콜백을 받는데요. readFile 함수는 파일을 읽다가 에러가 발생하면 콜백의 첫 번째 파라미터(error)에, 해당 에러 객체를 전달하고 콜백을 실행합니다. 만약 파일을 정상적으로 다 읽었으면 콜백의 두 번째 파라미터(data)에, 읽어들인 파일 내용을 전달하고 콜백을 실행하는데요.

이 readFile 메소드도, 콜백을 파라미터에 바로 넣는 비동기 실행 함수라는 점에서 setTimeout 함수, addEventListener 메소드와 비슷합니다. 그런데 이런 형식의 함수(또는 메소드)들은 한 가지 단점이 있다고 했었죠?(참고) 그건 바로 콜백 헬(callback hell) 문제입니다. 예를 들어, 위 코드에서 이제 file1.txt 파일의 내용을 출력하고 나서 그 다음에 file2.txt라는 파일의 내용을 또 출력해야한다고 해봅시다. 그럼 코드가 이렇게 되겠죠?

fs.readFile('file1.txt', 'utf8', (error1, data1) => {
  if (error1) {
    console.log(error1);
  } else {
    console.log(data1);
    fs.readFile('file2.txt', 'utf8', (error2, data2) => {
      if (error2) {
        console.log(error2);
      } else {
        console.log(data2);
      }
    });
  }
});
이렇게 코드를 쓰면 file1.txt의 내용이 출력되고, 그 다음에 file2.txt의 내용이 출력될 겁니다. 코드가 좀 복잡해졌지만 아직은 읽을만한 것 같습니다. 그런데 이제 그 다음으로 file3.txt의 내용도 출력해야 한다고 해봅시다.

그렇다면

fs.readFile('file1.txt', 'utf8', (error1, data1) => {
  if (error1) {
    console.log(error1);
  } else {
    console.log(data1);
    fs.readFile('file2.txt', 'utf8', (error2, data2) => {
      if (error2) {
        console.log(error2);
      } else {
        console.log(data2);
        fs.readFile('file3.txt', 'utf8', (error3, data3) => {
          if (error3) {
            console.log(error3);
          } else {
            console.log(data3);
          }
        });
      }
    });
  }
});
코드가 이렇게 됩니다. 이제 코드를 읽기 너무 어려워지지 않았나요?

콜백을 바로 파라미터에 집어넣는 전통적인 형식의 비동기 실행 함수들은 이런 문제가 있습니다. 바로 순차적으로 비동기 실행 함수들을 실행하려고 하면 콜백 안에 또 콜백이 있고, 그 안에 또 콜백이 있는 콜백 헬(콜백 지옥, callback hell) 현상을 초래하게 된다는 겁니다.

실제로 실무에서 개발을 하다 보면 이런 콜백 헬이 아주 큰 문제가 됩니다. 그런데 이런 함수들은 Promise 객체를 리턴하는 것도 아니고 애초에 이런 형식으로 정의되어 있기 때문에 문제를 해결하기가 어려워 보이는데요. 이 문제에 대한 대표적인 해결책이 바로 우리가 배운 Promisify입니다.

지금 이 readFile 메소드를 Promisify해보겠습니다.

function readFile_promisified(filename) {
  const p = new Promise((resolve, reject) => {
    fs.readFile(filename, 'utf8', (error, data) => {
      if (error) {
        reject(error); // 에러 발생 시 -> rejected
      } else {
        resolve(data); // 파일 내용 읽기 완료 -> fulfilled
      }
    });
  });
  return p;
}
이런 식으로 readFile_promisified라는 이름의 함수를 정의했는데요. 지금 함수 안에서는 Promise 객체를 직접 생성하고 있습니다. 
그리고 Promise 객체가 생성될 때 실행되는 executor 함수 안에서는 fs 객체의 readFile 메소드를 호출했습니다.

여기서 중요한 것은 작업을 수행하다가 에러가 나면 readFile 함수의 콜백에서


...                         (error, data) => {
  if (error) {
    reject(error); // 에러 발생 시 -> rejected 
  } else {
    resolve(data); // 파일 내용 읽기 완료 -> fulfilled 
  }
}
reject 함수를 호출하고, 파일의 내용을 정상적으로 다 읽었을 때는 resolve 함수를 호출한다는 사실입니다. 그리고 reject 함수의 파라미터에는 error 객체를, resolve 함수의 파라미터에는 파일의 내용인 data를 전달했는데요. 이 각각은, 생성된 Promise 객체의 작업 실패 정보 또는 작업 성공 결과가 되겠죠?

이제 readFile 메소드를 Promisify해서 만든 readFile_promisified 함수를 사용해서 위의 콜백 헬 코드에서 작성했던 내용을 똑같이 작성해봅시다.

readFile_promisified('file1.txt')
  .then((data) => { console.log(data); return readFile_promisified('file2.txt'); })
  .then((data) => { console.log(data); return readFile_promisified('file3.txt'); })
  .then((data) => { console.log(data); })
  .catch((error) => { console.log(error); });
짠! 어떤가요? 코드가 훨씬 깔끔해졌죠? readFile_promisified 함수는 Promise 객체를 리턴하기 때문에 이렇게 자유롭게 Promise Chain 안에서 사용할 수 있습니다.

이렇게 원하는 경우에는 전통적인 형식의 비동기 실행 함수를 Promisify해서 콜백 헬을 방지하고, 가독성 높은 코드를 작성할 수 있습니다.

3. Promisify를 하면 안 되는 함수들도 있습니다.
이제 기존의 전통적인 형식의 비동기 실행 함수도 원하는 경우에는 Promisify해서 콜백 헬을 방지할 수 있다는 것을 알게 되었습니다. 하지만 전통적인 형식의 비동기 실행 함수라고 해서 모두 Promisify해서 사용해도 되는 것은 아닙니다.

기존의 비동기 실행 함수들 중에서도 그 콜백을 한번만 실행하는 것들(setTimeout, readFile 등)만 Promisify해서 사용해도 되는데요.

이것들과 달리 만약 콜백을 여러 번 실행하는 함수들(setInterval, addEventListener 등)인 경우에는 이렇게 Promisify하면 안 됩니다. 왜냐하면 Promise 객체는 한번 pending 상태에서 fulfilled 또는 rejected 상태가 되고나면 그 뒤로는 그 상태와 결과가 바뀌지 않기 때문입니다. 이게 무슨 말인지 다음 코드를 보고 이해해봅시다.

const box = document.getElementById('test');
let count = 0;

function addEventListener_promisified(obj, eventName) { // 이런 Promisify는 하지 마세요
  const p = new Promise((resolve, reject) => {
    obj.addEventListener(eventName, () => { // addEventListener 메소드
      count += 1;
      resolve(count);
    });
  });
  return p;
}

addEventListener_promisified(box, 'click').then((eventCount) => { console.log(eventCount); });
이 코드에서 보이는 addEventListener_promisified 함수는 DOM 객체의 addEventListener 메소드를 Promisify한 함수인데요.

지금 Promise 객체가 생성될 때 실행되는 executor 함수 안에서는, DOM 객체에 어떤 이벤트가 발생할 때, 실행할 콜백을 등록하고 있습니다. 
특정 이벤트가 발생할 때마다 count라고 하는 변수의 값을 1씩 늘려서 resolve 함수의 파라미터로 전달해서 실행하도록 하는 내용이 들어있는데요.

마지막 코드를 보면,

addEventListener_promisified(box, 'click')
  .then((eventCount) => { console.log(eventCount); });
이렇게 addEventListener_promisified 함수의 아규먼트로 DOM 객체 box와 문자열 'click'을 넣어서 box 객체가 클릭 이벤트에 반응하도록 했습니다. 
(HTML 코드는 생략된 상태입니다.)

하지만 이 코드를 실행하고 box를 클릭해보면 
처음에 1이 딱 출력되고 나서 그 다음 count 값들은 출력되지 않습니다.

왜냐하면 pending 상태에 있던 Promise 객체(여기서는 p 객체)가 한번 fulfilled 상태 또는 rejected 상태가 되고 나면 
Promise 객체의 상태 및 결과가 고정되어 그 뒤로는 바뀌지 않기 때문입니다.

따라서 지금 위 코드에 보이는 resolve(count)라고 하는 코드가 box 버튼을 클릭할 때마다 여러 번 실행된다고 해도 p 객체가 갖고 있는 상태와 결과는 변하지 않습니다. 그래서 then 메소드 안의 콜백도 처음 클릭했을 때 딱 한번 실행되고 끝인 겁니다.

이렇게 콜백이 여러 번 실행되어야하는 비동기 실행 함수인 경우에는 Promisify를 하면 안 됩니다. Promisify를 하고 싶은 경우라도, 콜백이 딱 한 번 실행되는 함수인 경우에만 해야한다는 사실, 잘 기억하세요!




# 이미 상태가 결정된 Promise 객체
이때까지 우리는 pending 상태에 있다가 fulfilled 상태 또는 rejected 상태가 되는 Promise 객체를 직접 만드는 법을 배웠습니다. 그런데 아예 처음부터 바로 fulfilled 상태이거나 rejected 상태인 Promise 객체를 만드는 것도 가능한데요. 어떻게 할 수 있는지 살펴봅시다.

1. 이미 상태가 결정된 Promise 객체 만들기
(1) fulfilled 상태의 Promise 객체 만들기
const p = Promise.resolve('success');
Promise의 resolve라는 메소드를 사용하면 바로 fulfilled 상태의 Promise 객체를 만들 수 있습니다. 위와 같이 쓰면 fulfilled 상태이면서, 작업 성공 결과로 문자열 'success'를 가진 Promise 객체를 만들 수 있습니다.

(2) rejected 상태의 Promise 객체 만들기
const p = Promise.reject(new Error('fail'));
Promise의 reject라는 메소드를 사용하면 바로 rejected 상태의 Promise 객체를 만들 수 있습니다. 위와 같이 쓰면 rejected 상태이면서, 작업 실패 정보로, fail이라는 메시지를 가진 Error 객체를 가진 Promise 객체를 만들 수 있습니다.

Promise 객체를 직접 생성하는 방법에는 이전에 배웠던 것처럼

const p = new Promise((resolve, reject) => {

});
new 생성자와 executor 함수를 사용하는 것 말고도 resolve 메소드나, reject 메소드를 사용하는 방법도 있다는 사실을 기억하셔야 합니다. 
resolve 메소드나 reject 메소드로 생성한 Promise 객체도 이때까지 우리가 배운 것과 동일하게 작동합니다.

const p = Promise.resolve('success');
p.then((result) => { console.log(result); }, (error) => { console.log(error); });
이 코드에서는 첫 번째 콜백이 실행되어서 작업 성공 결과인 문자열 success가 출력되고

const p = Promise.reject(new Error('fail'));
p.then((result) => { console.log(result); }, (error) => { console.log(error); });
이 코드에서는 두 번째 콜백이 실행되어서 작업 실패 정보인 Error 객체의 내용이 출력되겠죠?

어떤 비동기 작업을 처리할 필요가 있다면, new 생성자와 executor 함수를 사용해서 Promise 객체를 만들어야 하지만, 그렇지 않고 바로 상태가 이미 결정된 Promise 객체를 만들고 싶을 때는 이 resolve 또는 reject 메소드를 사용합니다.

구체적으로 예를 들자면, 함수 안에서 리턴하는 값이 여러 개인 경우 모든 리턴값을 Promise 객체로 통일하고 싶을 때, 종종 resolve 또는 reject 메소드를 쓰는데요. 예를 들어,

function doSomething(a, b) {
    //~~
  if (problem) {
    throw new Error('Failed due to..'));
  } else {
    return fetch('https://~');
  }
}
이렇게 문제(problem이 falsy인 경우)가 없는 경우에만 fetch 함수를 호출해서 Promise 객체를 리턴하는 함수가 있다고 해봅시다. 만약 문제가 발생하는 경우에는 바로 Error 객체를 throw해 버리고 있죠? 만약 문제가 존재하는 경우에도 Promise 객체를 리턴하고 싶다면 reject 메소드를 써서 이렇게 작성할 수 있습니다.

function doSomething(a, b) {
  // ~~
  if (problem) {
    return Promise.reject(new Error('Failed due to..'));
  } else {
    return fetch('https://~');
  }
}
지금 문제가 있는 경우에도 에러를 바로 throw하는 게 아니라, 생성한 에러를 Promise 객체의 작업 실패 정보로 설정해서, 그 Promise 객체를 리턴하는 것으로 바꿔줬죠? 만약 어떤 함수가 어떤 상황이든 항상 Promise 객체를 리턴하는 것으로 통일하고 싶은 경우에는 resolve나 reject 메소드를 유용하게 사용할 수 있습니다.

2. Promise 객체의 작업 성공 결과 또는 작업 실패 정보
간혹 Promise 객체를 공부하는 분들 중에, Promise 객체가 pending 상태일 때 미리 then 메소드가 붙어있어야만 나중에 이 Promise 객체가 fulfilled 상태 또는 rejected 상태가 되었을 때 그 결과(작업 성공 결과 또는 작업 실패 정보)를 콜백의 파라미터로 받을 수 있고, 이미 fulfilled 상태 또는 rejected 상태가 된 Promise 객체의 경우에는 then 메소드를 붙여도 그 결과를 콜백에서 받지 못한다고 오해하는 분들이 있습니다.

하지만 방금 resolve, reject 메소드에서도 봤듯이 이미 fulfilled 또는 rejected 상태가 결정된 Promise 객체라도 then 메소드를 붙이면, 콜백에서 해당 작업 성공 결과 또는 작업 실패 정보를 받아올 수 있습니다. 시점과는 전혀 상관이 없는 개념인 겁니다.

Promise 객체의 상태가 fulfilled 또는 rejected 상태이기만 하면, 어느 시점이든, 몇 번이든 then 메소드를 붙여서 해당 결과를 가져올 수 있습니다. 예를 들어,

const p = new Promise((resolve, reject) => {
  setTimeout(() => { resolve('success'); }, 2000); // 2초 후에 fulfilled 상태가 됨
});

p.then((result) => { console.log(result); }); // Promise 객체가 pending 상태일 때 콜백 등록
setTimeout(() => { p.then((result) => { console.log(result); }); }, 5000); // Promise 객체가 fulfilled 상태가 되고 나서 콜백 등록 
이 코드를 실행하면 Promise가 pending 상태일 때 등록한 콜백이든, fulfilled 상태가 된 후에 등록한 콜백이든 잘 실행되는 것을 알 수 있습니다.
이렇게 어느 시점이든, 몇 번의 then 메소드를 붙이든 상관없이, pending 상태만 아니라면 항상 then 메소드로 Promise 객체의 결과를 추출할 수 있습니다.

Promise 객체는 항상 결과를 줄 수 있는 공급자(Provider)이고 그것의 then 메소드는 그 결과를 소비하는 콜백인 소비자(Consumer)를 설정하는 메소드라는 사실을 잘 기억하셔야 합니다. 시점과는 전혀 연관이 없으니까 오해하지 마세요!


# 조건 연산자 (Conditional operator) //반복문으로 사용 불가
# 조건 ? 조건이 truthy 할 때 표현식 : 조건이 falsy 할 때 표현식;
const CUT_OFF = 80;

function passChecker(score) {
    return score > CUT_OFF ? '합격' : '불합격!';
}

console.log(passChecker(75));

#if문
const CUT_OFF = 80;

function passChecker(score) {
    if (score > CUT_OFF) {
        return '합격'
    } else {
        return '불합격!';
    }
}

console.log(passChecker(75));

# 반복문
const CUT_OFF = 80;

function passChecker(score) {
    if (score > CUT_OFF) {
        const msg = '합격!';
        return msg;
    } else {
        for (let i = 0; i < 3; i++) {
            console.log(i);
        }
        return '불합격!';
    }
}

console.log(passChecker(75));


# Spread 구문 (Spread Syntax)
const number = [1, 2, 3];
console.log(...numbers);
console.log(1, 2, 3);

# Spread
const webPublishing = ['HTML', 'CSS'];
const interactiveWeb = [...webPublishing, 'JavaScript'];

interactiveWeb.push('JavaScript');

console.log(webPublishing);
console.log(interactiveWeb);

# argument문
const sumAll = (...args) => {
    let sum = 0;
    for (arg of args) {
        sum += arg;
    }
    return sum;
}

console.log(sumAll(1, 2, 3, 4));


# Spread 합칠때
const arr1 = [1, 2, 3];
const arr1 = [4, 5, 6];

const arr3 = [...arr1, ...arr2];
console.log(arr3);

const arr4 = arr1.concat(arr2);
console.log(arr4);


#
const members = ['태호', '종훈', '우재'];

const newObject = {...members };

console.log(newObject);


# 정리
객체 Spread하기
아래 코드를 살펴봅시다.

const codeit = { 
  name: 'codeit', 
};

const codeitClone = { 
  ...codeit, // spread 문법!
};

console.log(codeit); // {name: "codeit"}
console.log(codeitClone); // {name: "codeit"}
이렇게 중괄호 안에서 객체를 spread 하게되면, 해당 객체의 프로퍼티들이 펼쳐지면서 객체를 복사할 수가 있게 됩니다.

const latte = {
  esspresso: '30ml',
  milk: '150ml'
};

const cafeMocha = {
  ...latte,
  chocolate: '20ml',
}

console.log(latte); // {esspresso: "30ml", milk: "150ml"}
console.log(cafeMocha); // {esspresso: "30ml", milk: "150ml", chocolate: "20ml"}
이런 식으로 다른 객체가 가진 프로퍼티에 다른 프로퍼티를 추가해서 새로운 객체를 만들 때 활용할 수도 있겠죠?

주의 사항
배열을 Spread 하면 새로운 배열을 만들거나 함수의 아규먼트로 쓸 수 있었지만, 객체로는 새로운 배열을 만들거나 함수의 아규먼트로 사용할 수는 없습니다.

const latte = {
  esspresso: '30ml',
  milk: '150ml'
};

const cafeMocha = {
  ...latte,
  chocolate: '20ml',
}

[...latte]; // Error

(function (...args) {
  for (const arg of args) {
    console.log(arg);
  }
})(...cafeMocha); // Error
그렇기 때문에 객체를 spread할 때는 반드시 객체를 표현하는 중괄호 안에서 활용해야 한다는 점. 잘 기억해 두시면 좋을 것 같습니다!


#문제
const snacks = ['원카칩', '꿀버터칩', '헛스윙칩', '태양칩', '야채시간'];
const drinks = ['사이다', '콜라', '우유', '물', '커피', '레몬에이드'];

function printArguments(...args) {
  for (const arg of args) {
    console.log(arg);
  }
}

// 1. Spread 구문을 활용해서 snacks와 drinks 배열을 각각 mySnacks와 myDrinks 변수에 복사해 주세요
const mySnacks = [...snacks];
const myDrinks = [...drinks];

mySnacks.splice(2, 3);
myDrinks.splice(1);

// 2. Spread 구문을 활용해서 mySnacks와 myDrinks 순서로 두 배열을 합쳐서 myChoice 변수에 할당해 주세요
const myChoice = [...mySnacks, ...myDrinks];

// 3. Spread 구문을 활용해서 myChoice의 각 요소들을 printArguments 함수의 아규먼트로 전달해 주세요
printArguments(...myChoice);


# 옵셔널 체이닝 (Optional Chaining)
바로 ECMAScript2020에서 등장한 옵셔널 체이닝이라는 접근 방법입니다. 일반적으로 객체의 프로퍼티는 점 표기법을 통해서 접근하게 되는데요.

function printCatName(user) {
  console.log(user.cat.name);
}

const user1 = {
  name: 'Captain',
  cat: {
    name: 'Crew',
    breed: 'British Shorthair',
  }
}

printCatName(user1); // Crew

객체를 활용해서 데이터를 표현하다 보면 이렇게 중첩된 객체를 작성하게 될 일이 빈번하고, 함수에서도 이런 중첩 객체의 프로퍼티를 활용할 일이 많은데요.
중첩된 객체의 프로퍼티에 접근하는 방법은 이미 다 알고 계시죠? 함수 printCatName은 user 파라미터에 중첩된 cat객체의 name 프로퍼티를 콘솔에 출력해주는 함수입니다.

그런데, 이렇게 중첩 객체를 다룰 때 한가지 조심해야 될 부분이 있습니다.

const user2 = {
  name: 'Young',
}

console.log(user2.cat); // undefined
printCatName(user2); // TypeError: Cannot read property 'name' of undefined
여러 가지 상황에 맞춰 데이터를 다루다 보면 때로는 우리가 예상한 프로퍼티를 가지고 있지 않을 수도 있는데요.
cat 프로퍼티를 가지고 있지 않은 user2는 cat 프로퍼티가 undefined이기 때문에 user2.cat.name에 접근하려는 순간 에러가 발생하게 됩니다.

그래서 printCatName과 같이 중첩된 객체의 프로퍼티를 다룰 때는 user.cat.name에 접근하기 전에 user.cat이 null 혹은 undefined가 아니라는 것을 검증하고 접근해야 에러를 방지할 수가 있는데요.

function printCatName(user) {
  console.log(user.cat && user.cat.name);
}
if문을 활용할 수도 있지만, 일반적으로는 간결하게 AND 연산자를 활용해서 이 문제를 해결하곤 했었습니다.
그런데 이마저도 객체의 이름이나 프로퍼티의 이름이 길어질수록 가독성이 나빠지는 문제가 있는데요, 이런 상황에 훨씬 더 코드를 간결하게 사용할 수 있는 문법이 바로 옵셔널 체이닝(Optional Chaining)입니다.

function printCatName(user) {
  console.log(user.cat?.name);
}
위 코드에서 볼 수 있는 것처럼 물음표와 마침표를 붙여 사용하는 부분이 바로 옵셔널 체이닝 연산자(?.)인데요.
만약 옵셔널 체이닝 연산자 왼편의 프로퍼티 값이 undefined 또는 null이 아니라면 그다음 프로퍼티 값을 리턴하고 그렇지 않은 경우에는 undefined를 반환하는 문법입니다.

옵셔널 체이닝 연산자의 동작 원리를 삼항 연산자를 통해 구체적으로 표현하면 다음과 같이 작성할 수 있는데요.

function printCatName(user) {
  console.log((user.cat === null || user.cat === undefined) ? undefined : user.cat.name);
}
이렇게 보니 옵셔널 체이닝 연산자가 어떻게 동작하는지 이해가 되죠?
이전에 배운 null 병합 연산자와 함께 활용하면 다음과 같이 응용할 수도 있습니다.

function printCatName(user) {
  console.log(user.cat?.name ?? '함께 지내는 고양이가 없습니다.');
}

const user2 = {
  name: 'Young',
}

printCatName(user2); // 함께 지내는 고양이가 없습니다.
이후 레슨에서 자세히 다루겠지만 자바스크립트에서 에러를 방지하는 일은 굉장히 중요한데요.
중첩된 객체를 다룰 때 에러를 방지하기 위해 다양한 방식을 활용할 수 있지만 옵셔널 체이닝 연산자를 활용하면 훨씬 더 간결하게 코드를 작성할 수 있다는 점! 잘 기억해 두세요!


# Destructuring (구조 분해)
//Destructuring 문법을 활용하면 배열의 각 요소를 여러 변수에 개별적으로 할당할 수 있습니다. Destructuring 문법은 rest 문법을 활용할 수도 있고, 변수들끼리 서로 값을 바꿀 때도 유용하게 활용할 수 있는데요.


// 1. Destructuring 문법을 활용해서 numbers 배열의 각 요소를 one, two, three라는 변수에 할당해보세요
const numbers = [1, 2, 3];
const [one, two, three] = numbers;



// 2. Destructuring 문법을 활용해서 TV는 livingRoom, 나머지 요소들(배열)은 kitchen 변수에 할당해 주세요
const products = ['TV', '식탁', '냉장고', '전기밥솥', '전자레인지', '오븐', '식기세척기'];
const [livingRoom, ...kitchen] = products;



// 3. Destructuring 문법을 활용해서 두 변수의 값을 서로 바꿔주세요
let firstName = 'Kang';
let lastName = 'Young';
[firstName, lastName] = [lastName, firstName];



// 테스트 코드
console.log(one);
console.log(two);
console.log(three);
console.log(livingRoom);
console.log(kitchen[1]);
console.log(firstName);
console.log(lastName);



# Destructuring 연습



// 1. Destructuring 문법을 사용해서 title, artist, year, medium 변수에 myBestArt 객체의 각 프로퍼티를 할당해 주세요
const myBestArt = {
    title: '별이 빛나는 밤에',
    artist: '빈센트 반 고흐',
    year: 1889,
    medium: '유화',
}

const { title, artist, year, medium } = myBestArt;



// 2. Destructuring 문법을 활용해서 myBestSong의 프로퍼티 중 title과 artist는 각각 songName과 singer라는 변수에, 나머지는 rest라는 변수에 객체로 할당해 주세요
const myBestSong = {
    title: '무릎',
    artist: '아이유(IU)',
    release: '2015.10.23.',
    lyrics: '모두 잠드는 밤에...'
}

const { title: songName, artist: singer, ...rest } = myBestSong;



// 3. printMenu 함수 안에 잘못 작성된 Destructuring 코드를 수정해 주세요
const menu1 = { name: '아메리카노' };
const menu2 = { name: '바닐라 라떼', ice: true };
const menu3 = { name: '카페 모카', ice: false };

function printMenu(menu) {
    //  menu 파라미터로 전달되는 객체에 ice 프로퍼티가 없을 경우 기본값은 true여야 합니다
    const { name, ice = true } = menu;

    console.log(`주문하신 메뉴는 '${ice ? '아이스' : '따뜻한'} ${name}'입니다.`);
}



// 테스트 코드
console.log(title);
console.log(artist);
console.log(year);
console.log(medium);
console.log(songName);
console.log(singer);
console.log(rest);
printMenu(menu1);
printMenu(menu2);
printMenu(menu3);


# 에러와 에러 객체
throw error;
throw new Error('에러가 발생했습니다.');

// 에러 종류 : https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Error

## try catch문
try {
    // 코드
} catch (error) {
    console.log('에러 후'); // 에러가 발생했을 때 동작할 코드
}
// error & err & e 라고 사용하기도 함.

try {
    // 코드
} catch (e) {
    console.log('에러 후'); // 에러가 발생했을 때 동작할 코드
    console.log(e);  //console.error(e); 에러문으로 확인 가능
    console.log(e.name);
    console.log(e.message);
}


# finally문

try {
  // 실행할 코드
} catch (err) {
  // 에러가 발생했을 때 실행할 코드
} finally {
  // 항상 실행할 코드
}

# 
  for (const member of members) {
    console.log(member);
  }
}

try {
  printMembers('영훈', '윤수', '동욱');
} catch (err) {
  alert('에러가 발생했습니다!');
  console.error(err);
} finally {
  const end = new Date();
  const msg = `코드 실행을 완료한 시각은 ${end.toLocaleString()}입니다.`;
  console.log(msg);
}


# finally문에서의 에러 처리는?

try {
  try {
    // 실행할 코드
  } catch (err) {
    // 에러가 발생했을 때 실행할 코드
  } finally {
    // 항상 실행할 코드
  }
} catch (err) {
  // finally문에서 에러가 발생했을 때 실행할 코드
}


## 종합 정리
조건부 연산자 (Conditional operator)
삼항 연산자 (Ternary operator)라고도 불리는 이 연산자는 자바스크립트에서 세 개의 피연산자를 가지는 유일한 연산자 입니다.

if문과 같은 원리로 조건에 따라 값을 결정할 때 활용되는데요.

const cutOff = 80;

const passChecker = (score) => score > cutOff ? '합격입니다!' : '불합격입니다!';

console.log(passChecker(75));
간단한 조건식의 경우에는 if문 보다 훨씬 더 간결하게 표현할 수 있는 장점이 있지만 내부에 변수나 함수를 선언한다거나 반복문 같은 표현식이 아닌 문장은 작성할 수 없다는 한계가 있기 때문에 if문을 완벽하게 대체할 수는 없다는 점. 꼭 기억해 주세요!

Spread 구문
여러 개의 값을 묶어놓은 배열이나 객체와 같은 값은 바로 앞에 마침표 세 개를 붙여서 펼칠 수가 있습니다.

const webPublishing = ['HTML', 'CSS'];
const interactiveWeb = [...webPublishing, 'JavaScript'];

console.log(webPublishing);
console.log(interactiveWeb);

const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];

const arr3 = [...arr1, ...arr2];
console.log(arr3);
Spread 구문은 배열이나 객체를 복사하거나 혹은 복사해서 새로운 요소들을 추가할 때 유용하게 활용 될 수 있습니다.
참고로 배열은 객체로 펼칠 수 있지만 객체는 배열로 펼칠 수 없다는 부분도 잘 기억해 두시면 좋을 것 같습니다.

const members = ['태호', '종훈', '우재'];
const newObject = { ...members };

console.log(newObject); // {0: "태호", 1: "종훈", 2: "우재"}

const topic = {
  name: '모던 자바스크립트',
  language: 'JavaScript', 
}
const newArray = [...topic]; // TypeError!
모던한 프로퍼티 표기법
ES2015 이후부터는 자바스크립트에서 변수나 함수룰 활용해서 프로퍼티를 만들 때 프로퍼티 네임과 변수나 함수 이름이 같다면 다음과 같이 축약해서 사용할 수 있습니다.

function sayHi() {
  console.log('Hi!');
}

const title = 'codeit';
const birth = 2017;
const job = '프로그래밍 강사';

const user = {
  title, 
  birth, 
  job, 
  sayHi,
};

console.log(user); // {title: "codeit", birth: 2017, job: "프로그래밍 강사", sayHi: ƒ}
그리고 메소드를 작성할 때도 다음과 같이 function 키워드를 생략할 수가 있습니다.

const user = {
  firstName: 'Tess',
  lastName: 'Jang',
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(user.getFullName()); // Tess Jang
뿐만아니라 아래 코드와 같이 대괄호를 활용하면 다양한 표현식으로 프로퍼티 네임을 작성할 수도 있으니까 잘 기억해 두셨다가 유용하게 활용해 보세요!

const propertyName = 'birth';
const getJob = () => 'job';

const codeit = {
  ['topic' + 'name']: 'Modern JavaScript',
  [propertyName]: 2017,
  [getJob()]: '프로그래밍 강사',
};

console.log(codeit);
구조 분해 Destructuring
배열과 객체와 같이 내부에 여러 값을 담고 있는 데이터 타입을 다룰 때 Destructuring 문법을 활용하면, 배열의 요소나 객체의 프로퍼티 값들을 개별적인 변수에 따로 따로 할당해서 다룰 수가 있습니다.

// Array Destructuring
const members = ['코딩하는효준', '글쓰는유나', '편집하는민환'];
const [macbook, ipad, coupon] = members;

console.log(macbook); // 코딩하는효준
console.log(ipad); // 글쓰는유나
console.log(coupon); // 편집하는민환

// Object Destructuring
const macbookPro = {
  title: '맥북 프로 16형',
  price: 3690000,
};

const { title, price } = macbookPro;

console.log(title); // 맥북 프로 16형
console.log(price); // 3690000
함수에서 default parater, rest parameter를 다루듯이 Destructuring 문법을 활용할 때도 기본값과 rest 문법을 활용할 수 있습니다.

// Array Destructuring
const members = ['코딩하는효준', '글쓰는유나', undefined, '편집하는민환', '촬영하는재하'];
const [macbook, ipad, airpod = '녹음하는규식', ...coupon] = members;

console.log(macbook); // 코딩하는효준
console.log(ipad); // 글쓰는유나
console.log(airpod); // 녹음하는규식
console.log(coupon); // (2) ["편집하는민환", "촬영하는재하"]

// Object Destructuring
const macbookPro = {
  title: '맥북 프로 16형',
  price: 3690000,
  memory: '16 GB 2667 MHz DDR4',
  storage: '1TB SSD 저장 장치',
};

const { title, price, color = 'silver', ...rest } = macbookPro;

console.log(title); // 맥북 프로 16형
console.log(price); // 3690000
console.log(color); // silver
console.log(rest); // {memory: "16 GB 2667 MHz DDR4", storage: "1TB SSD 저장 장치"}
에러와 에러 객체
자바스크립트에서 에러를 다루는 일은 굉장히 중요하다고 할 수 있는데요.
자바스크립트에서 에러가 발생하면 그 순간 프로그램 자체가 멈춰버리고 이후의 코드가 동작하지 않기 때문입니다.

그리고 에러가 발생하면 에러에 대한 정보를 name과 message라는 프로퍼티로 담고 있는 에러 객체가 만들어지는데요.
대표적인 에러 객체는 SyntaxError, ReferenceError, TypeError 입니다.

에러 객체는 직접 만들 수도 있는데요.
new 키워드와 에러 객체 이름을 딴 함수를 통해 에러 객체를 만들 수 있고, throw 키워드로 에러를 발생시킬 수 있습니다.

throw new TypeError('타입 에러가 발생했습니다.');
try...catch문
try...catch문은 자바스크립트에서 대표적인 에러 처리 방법입니다.

try {
  // 실행할 코드
} catch (error) {
  // 에러 발생 시 동작할 코드
}
try문 안에서 실행할 코드를 작성하고, try문에서 에러가 발생한 경우에 실행할 코드를 catch 문 안에 작성하면 되는데요.
이 때 try문에서 발생한 에러 객체가 catch문의 첫 번째 파라미터로 전달됩니다. 만약, try문에서 에러가 발생하지 않을 경우 catch문의 코드는 동작하지 않습니다.

그리고 try...catch문에서 에러의 유무와 상관없이 항상 동작해야할 코드가 필요하다면 finally문을 활용할 수 있습니다.

try {
  // 실행할 코드
} catch (error) {
  // 에러가 발상했을 때 실행할 코드
} finally {
  // 항상 실행할 코드
}

