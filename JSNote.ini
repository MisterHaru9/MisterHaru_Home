#  반복문

while (조건){
    반복해서 실행할 코드
}


while (true) {
    console.log("Hello MisterHaru!");
}


while (true) {
    document.write("Hello MisterHaru! <br />" );
}

#  while 문
var i = 1;

while(i < 10) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
    i++
}

#  for 문

for(var i = 1; i < 16; i++) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
}

var ID = misterharu;
alert(prompt("아이디를 입력하세요!"));
if(misterharu){"안녕하세요!" + ID +"님."
} else alert("아이디 입력이 틀렸습니다.");

for(var i = 1; i < 16; i++) {
    document.write(i + "팀 " + "Hello MisterHaru! <br />" );
}



#  break & continue 문

for(var i = 0; i < 10; i++){
    if(i === 5) {
        break;
    }
    document.write('coding everybody'+i+'<br />');
}




for(var i = 0; i < 10; i++){
    if(i === 5) {
        continue;
    }
    document.write('coding everybody'+i+'<br />');
}



# 함수의 형식
function 함수명( [인자...[,인자]] ){
    코드
    return 반환값
}


# 객체(Object)
var grades = {'egoing': 10, 'k8805': 6, 'sorialgi': 80};


// RegExr expression - 치환
var pattern = /(\w+)\satisfies(\w+)/;
var str = "conding everybody";
var result = str.replace(pattern, "$2, $1");
console.log(result);

var urlPattern = /\b(?:https?):\/\/[a-z0-9-+&@#\/%?=~_|!:,.;]*/gim;
var content = '생활코딩 : http://opentutorials.org/course/1 입니다. 네이버 : http://naver.com 입니다. ';
var result = content.replace(urlPattern, function(url){
    return '<a href="'+url+'">'+url+'</a>';
});
console.log(result);
\


//전역변수의 사용
MYAPP = {}
MYAPP.calculator = {
    'left' : null,
    'right' : null
}
MYAPP.coordinate = {
    'left' : null,
    'right' : null
}
 
MYAPP.calculator.left = 10;
MYAPP.calculator.right = 20;
function sum(){
    return MYAPP.calculator.left + MYAPP.calculator.right;
}
document.write(sum());


//전역 변수를 지역 변수로 변경
(function(){
    var MYAPP = {}
    MYAPP.calculator = {
        'left' : null,
        'right' : null
    }
    MYAPP.coordinate = {
        'left' : null,
        'right' : null
    }
    MYAPP.calculator.left = 10;
    MYAPP.calculator.right = 20;
    function sum(){
        return MYAPP.calculator.left + MYAPP.calculator.right;
    }
    document.write(sum());
}())



//함수는 함수의 리턴 값으로도 사용할 수 있다.
function cal(mode){
    var funcs = {
        'plus' : function(left, right){return left + right},
        'minus' : function(left, right){return left - right}
    }
    return funcs[mode];
}
alert(cal('plus')(2,1));
alert(cal('minus')(2,1));   


//당연히 배열의 값으로도 사용할 수 있다.
var process = [
    function(input){ return input + 10;},
    function(input){ return input * input;},
    function(input){ return input / 2;}
];
var input = 1;
for(var i = 0; i < process.length; i++){
    input = process[i](input);
}
alert(input);



# 처리의 위임
//값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수로 전달할 수 있다. 값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 완전히 바꿀 수 있다. 인자로 전달된 함수 sortNumber의 구현에 따라서 sort의 동작방법이 완전히 바뀌게 된다.

function sortNumber(a,b){
    // 위의 예제와 비교해서 a와 b의 순서를 바꾸면 정렬순서가 반대가 된다.
    return b-a;
}
var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
alert(numbers.sort(sortNumber)); // array, [20,10,9,8,7,6,5,4,3,2,1]


// 클랜 획득 점수에 따른 리더보드 순위와 구분을 할 수 있다.

var numbers = [20, 10, 9,8,7,6,5,4,3,2,1];
var sortfunc = function(a, b){
    return b - a;
}
console.log(numbers.sort(sortfunc));


# 비동기 처리
<!DOCTYPE html>
<html>
<head>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
</head>
<body>
<script type="text/javascript">
    $.get('./datasource.json.js', function(result){
        console.log(result);
    }, 'json');
</script>
</body>
</html>



# 클로저
function outter(){
    var title = 'coding everybody';  
    return function(){        
        alert(title);
    }
}
inner = outter();
inner();


//

function factory_movie(title){
    return {
        get_title : function (){
            return title;
        },
        set_title : function(_title){
            if(typeof _title === 'String'){
                title = _title
            } else {
                alert('제목은 문자열이어야 합니다.');
            }
            
        }
    }
}
ghost = factory_movie('Ghost in the shell');
matrix = factory_movie('Matrix');
 
alert(ghost.get_title());
alert(matrix.get_title());
 
ghost.set_title('공각기동대');
 
alert(ghost.get_title());
alert(matrix.get_title());



//
var arr = []
for(var i = 0; i < 5; i++){
    arr[i] = function(id) {
        return function(){
            return id;
        }
    }(i);
}
for(var index in arr) {
    console.log(arr[index]());
}



# arguments

function sum(){
    var i, _sum = 0;    
    for(i = 0; i < arguments.length; i++){
        document.write(i+' : '+arguments[i]+'<br />');
        _sum += arguments[i];
    }   
    return _sum;
}
document.write('result : ' + sum(1,2,3,4));



//
function zero(){
    console.log(
        'zero.length', zero.length,
        'arguments', arguments.length
    );
}
function one(arg1){
    console.log(
        'one.length', one.length,
        'arguments', arguments.length
    );
}
function two(arg1, arg2){
    console.log(
        'two.length', two.length,
        'arguments', arguments.length
    );
}
zero(); // zero.length 0 arguments 0 
one('val1', 'val2');  // one.length 1 arguments 2 
two('val1');  // two.length 2 arguments 1



//
function sum(arg1, arg2){
    return arg1+arg2;
}
alert(sum.apply(null, [1,2]))


# apply

sum.apply(null, [1.2]);


//
o1 = {val1:1, val2:2, val3:3}
o2 = {v1:10, v2:50, v3:100, v4:25}
function sum(){
    var _sum = 0;
    for(name in this){
        _sum += this[name];
    }
    return _sum;
}
alert(sum.apply(o1)) // 6
alert(sum.apply(o2)) // 185


//
var preson = {}
preson.name = 'egoing';
preson.introduce = function(){
    return 'My name is'+this.name;
}
document.write(preson.introduce());



//생성자 함수는 일반함수와 구분하기 위해서 첫글자를 대문자로 표시한다.
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");

var p2 = new Person('leezche');
document.write(p2.introduce());


// apply call 을 이용해서 this의 값을 제어
var o = {}
var p = {}
function func(){
    switch(this){
        case o:
            document.write('o<br />');
            break;
        case p:
            document.write('p<br />');
            break;
        case window:
            document.write('window<br />');
            break;          
    }
}
func();
func.apply(o);
func.apply(p);

# 상속(inheritance)
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");


// 수정
function Person(name){
    this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
    return 'My name is '+this.name; 
}

function Programmer(name){
    this.name = name;
}
Programmer.prototype = new Person();
Programmer.prototype.coding = function(){
    return "hello world";
}

function Designer(name){
    this.name = name;
}
Designer.prototype = new Person();
Designer.prototype.design = function(){
    return "beautiful!";
}

var p1 = new Programmer('egoing');
document.write(p1.introduce()+"<br />");
document.write(p1.coding()+"<br />");

var p2 = new Designer('Haru');
document.write(p2.introduce()+"<br />");
document.write(p2.design()+"<br />");


# prototype
Array.prototype.rand = function(){
    var index = Math.floor(this.length*Math.random());
    return this[index];
}
var arr = new Array('seoul','new york','ladarkh','pusan', 'Tsukuba');
console.log(arr.rand());


#  Object
Object.prototype.contain = function(neddle) {
    for(var name in this){
        if(this[name] === neddle){
            return true;
        }
    }
    return false;
}
var o = {'name':'egoing', 'city':'seoul'}
console.log(o.contain('egoing'));
var a = ['egoing','leezche','grapittie'];
console.log(a.contain('leezche'));
//
for(var name in o){
    if(o.hasOwnProperty(name))
        console.log(name);  
}

// 입력연습
Object.prototype.contain = function(MisterHaru){
    for(var name in this){
        if(this[name] === MisterHaru){
            return true;
        }
    }
}


#  hasOwnProperty 에 대해 추가 공부 필요

//Wrapper Object 레퍼 객체 , 원시 데이터 타입
// var str = 'coding';
// str = new String('coding');

var str = 'coding';
console.log(str.length);        // 6
console.log(str.charAt(0));     // "C"

var str = 'coding';
str.prop = 'everybody';
console.log(str.prop);      // undefined


// 밤 낮 화이트 블랙 변경
<input type="button" value="night" onclick="
    document.querySelector('body').style.backgroundColor='black;
    document.querySelector('body').style.color='white';
">
<input type="button" value="day" onclick="
    document.querySelector('body').style.backgroundColor='white;
    document.querySelector('body').style.color='black';
">

//
<input type="button" value="hi" onclick="alert('hi')">
<input type="text" onchange="alert('changed')">
<input type="text" onkeydown="alert('key down!')">



/////////////


요약
문자열에서 인자로 주어진 값에 해당하는 문자를 리턴한다.

문법
# charAt(index)
인자
index - 필수, 0보다 큰 정수

설명
문자열에 속하는 문자는 왼쪽부터 오른쪽까지 0부터 인덱싱되어 있다.
charAt은 index로 주어진 값에 해당하는 문자를 리턴한다.
인덱스는 0부터 시작하기 때문에 index로 들어갈 수 있는 가장 큰 수는 (문자열.legnth-1)이다.
존재하지 않는 index를 인자로 전달하면 공백이 출력된다.
charAt 는 index에 해당하는 문자를 리턴하고, chartCodeAt은 유니코드 값을 리턴하는 차이가 있다.

예제
var stringName = 'coding everybody';
alert(stringName.charAt(0)); // c
alert(stringName.charAt(stringName.length-1)); // y
alert(stringName.charAt(1000) == ''); // true



#  charCodeAt
요약
index에 해당하는 문자의 unicode 값을 리턴

문법
string.charCodeAt(index)
인자
index - 필수, 0보다 큰 정수

설명
유니코드는 모든 시스템에서 일관되게 문자를 표현하기 위한 산업표준이다.
charCodeAt은 주어진 index에 해당하는 유니코드 값을 리턴하는데 이 값은 unicode가 지원되는 모든 시스템에서 동일한 문자를 가르킨다.
charAt 는 index에 해당하는 문자를 리턴하고, chartCodeAt은 유니코드 값을 리턴하는 차이가 있다.

예제
var stringName = '생활코딩'
alert(stringName.charCodeAt(0)); // 493373 
// http://www.unicode.org/charts/PDF/UAC00.pdf 에서 '생'을 찾아보면 'C0DD'인데 이것은 16진수다. 
// 이를 10진수로 변환하면 493373이 된다

395로5168

# 웹브라우저와 javascript

JavaScript
HTML을 프로그래밍적으로 제어한다. 


<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
        #selected{
            color:red;
        }
        .dark {
            background-color:black;
            color:white;
        }
        .dark #selected{
            color:yellow;
        }
    </style>
</head>
<body>
    <ul>
        <li>HTML</li>
        <li>CSS</li>
        <li id="selected">JavaScript</li>
    </ul>
    <input type="button" onclick="document.body.className='dark'" value="dark" />
</body>
</html>



//
<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
    <input type="button" id="hw" value="hello world">
    <script type="text/javascript">
        var hw = document.getElementById('hw');
        hw.addEventListener('click', function(){
            alert('Hello world');
        })
    </script>
</body>
</html>




///

<!DOCTYPE html>
<html>
<body>
    <input type="button" id="hw" value="Hello world" />
    <script type="text/javascript" src="script2.js"></script>
</body>
</html>


* script2.js
var hw = document.getElementById('hw');
hw.addEventListener('click', function(){
    alert('Hello world');
})




window.onload = function(){
    var hw = document.getElementById('hw');
    hw.addEventListener('click', function(){
        alert('Hello world');
    })
}
//window.onload = function(){} 
//html 모두를 웹브라우저에 실행후 마지막에 호출



# 전역객체
<!document html>
<html>
<script>
    alert('Hell world');
    window.alert('Hello World');
</script>
<body>
</body>
</html>

// Location 객체

// URL Parsing
console.log(location.protocol, location.host, location.port, location.pathname, location.search, location.hash)


//현재 문서를 http://egoing.net으로 이동한다.
location.href = 'http://egoing.net';
location = 'http://egoing.net';

# 리로드
location.href=location.href
location.reload();


# Navigator 객체
객체의 모든 프로퍼티를 열람할 수 있다.
console.dir(navigator);
console.dir(navigator.appName);
console.dir(navigator.appVersion);
console.dir(navigator.userAgent);
console.dir(navigator.platform);



//Object.keys라는 메소드는 객체의 key 값을 배열로 리턴하는 Object의 메소드다. 이 메소드는 ECMAScript5에 추가되었기 때문에 오래된 자바스크립트와는 호환되지 않는다. 아래의 코드를 통해서 호환성을 맞출 수 있다. 

// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys
if (!Object.keys) {
Object.keys = (function () {
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty,
        hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
        dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
        ],
        dontEnumsLength = dontEnums.length;

    return function (obj) {
    if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
        throw new TypeError('Object.keys called on non-object');
    }

    var result = [], prop, i;

    for (prop in obj) {
        if (hasOwnProperty.call(obj, prop)) {
        result.push(prop);
        }
    }

    if (hasDontEnumBug) {
        for (i = 0; i < dontEnumsLength; i++) {
        if (hasOwnProperty.call(obj, dontEnums[i])) {
            result.push(dontEnums[i]);
        }
        }
    }
    return result;
    };
}());
}


//
<!DOCTYPE html>
<html>
<style>li {padding:10px; list-style: none}</style>
<body>
<ul>
    <li>
        첫번째 인자는 새 창에 로드할 문서의 URL이다. 인자를 생략하면 이름이 붙지 않은 새 창이 만들어진다.<br />
        <input type="button" onclick="open1()" value="window.open('demo2.html');" />
    </li>
    <li>
        두번째 인자는 새 창의 이름이다. _self는 스크립트가 실행되는 창을 의미한다.<br />
        <input type="button" onclick="open2()" value="window.open('demo2.html', '_self');" />
    </li>
    <li>
        _blank는 새 창을 의미한다. <br />
        <input type="button" onclick="open3()" value="window.open('demo2.html', '_blank');" />
    </li>
    <li>
        창에 이름을 붙일 수 있다. open을 재실행 했을 때 동일한 이름의 창이 있다면 그곳으로 문서가 로드된다.<br />
        <input type="button" onclick="open4()" value="window.open('demo2.html', 'ot');" />
    </li>
    <li>
        세번재 인자는 새 창의 모양과 관련된 속성이 온다.<br />
        <input type="button" onclick="open5()" value="window.open('demo2.html', '_blank', 'width=200, height=200, resizable=yes');" />
    </li>
</ul>
 
<script>
function open1(){
    window.open('demo2.html');
}
function open2(){
    window.open('demo2.html', '_self');
}
function open3(){
    window.open('demo2.html', '_blank');
}
function open4(){
    window.open('demo2.html', 'ot');
}
function open5(){
    window.open('demo2.html', '_blank', 'width=200, height=200, resizable=no');
}
</script>
</body>
</html>


//제어 대상을 찾기
document.getElementsByTagName
document.getElementsByClassName
document.getElementById
document.querySelector 
document.querySelectorAll




# document.getElementsByTagName
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<script>
    var ul = document.getElementsByTagName('ul')[0];
    var lis = ul.getElementsByTagName('li');
    for(var i=0; lis.length; i++){
        lis[i].style.color='red';   
    }
</script>


# document.getElementsByClassName
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li class="active">JavaScript</li>
</ul>
<script>
    var lis = document.getElementsByClassName('active');
    for(var i=0; i < lis.length; i++){
        lis[i].style.color='red';   
    }
</script>
</body>
</html>


# document.getElementById
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li id="active">CSS</li>
    <li>JavaScript</li>
</ul>
<script>
    var li = document.getElementById('active');
    li.style.color='red';
</script>
</body>
</html>


# document.querySelector
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<ol>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li>JavaScript</li>
</ol>
 
<script>
    var li = document.querySelector('li');
    li.style.color='red';
    var li = document.querySelector('.active');
    li.style.color='blue';
</script>
</body>
</html>


//document.querySelectorAll
<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li>JavaScript</li>
</ul>
<ol>
    <li>HTML</li>
    <li class="active">CSS</li>
    <li>JavaScript</li>
</ol>

<script>
    var lis = document.querySelectorAll('li');
    for(var name in lis){
        lis[name].style.color = 'blue';
    }
</script>
</body>
</html>



#  jQuery

$ = jQuery function
$('li').css('color','red');
는 <li style="color:red"> 이다.

<!DOCTYPE html>
<html>
<head>
    <style>
    #demo{width:200px;float: left; margin-top:120px;}
    #execute{float: left; margin:0; font-size:0.9em;}
    #execute{padding-left: 5px}
    #execute li{list-style: none}
    #execute pre{border:1px solid gray; padding:10px;}
    </style>
</head>
<body>
<ul id="demo">
    <li class="active">HTML</li>
    <li id="active">CSS</li>
    <li class="active">JavaScript</li>
</ul>
<ul id="execute">
    <li>
        <pre>
var lis = document.getElementsByTagName('li');
for(var i=0; i&lt;lis.length; i++){
    lis[i].style.color='red';   
</pre>
        <pre>
$('li').css('color', 'red')     </pre>
        <input type="button" value="execute" onclick="$('li').css('color', 'red')" />
    </li>
    <li>
        <pre>
var lis = document.getElementsByClassName('active');
for(var i=0; i &lt; lis.length; i++){
    lis[i].style.color='red';   
}</pre>
        <pre>
$('.active').css('color', 'red')</pre>
        <input type="button" value="execute" onclick="$('.active').css('color', 'red')" />
    </li>
    <li>
        <pre>
var li = document.getElementById('active');
li.style.color='red';
li.style.textDecoration='underline';</pre>
        <pre>
$('$active').css('color', 'red').css('textDecoration', 'underline');
        </pre>
        <input type="button" value="execute" onclick="$('#active').css('color', 'red').css('textDecoration', 'underline')" />
    </li>
</ul>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
</body>
</html>


#  HTMLElement

<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="active">JavaScript</li>
</ul>
<script>
    var li = document.getElementById('active');
    console.log(li.constructor.name);
    var lis = document.getElementsByTagName('li');
    console.log(lis.constructor.name);
</script>

document.getElementById : 리턴 데이터 타입은 HTMLLIELement
document.getElementsByTagName : 리턴 데이터 타입은 HTMLCollection

실행결과가 하나인 경우 HTMLLIELement, 복수인 경우 HTMLCollection을 리턴하고 있다. 


# HTMLELement
<a id="anchor" href="http://opentutorials.org">opentutorials</a>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="list">JavaScript</li>
</ul>
<input type="button" id="button" value="button" />
<script>
    var target = document.getElementById('list');
    console.log(target.constructor.name);

    var target = document.getElementById('anchor');
    console.log(target.constructor.name);

    var target = document.getElementById('button');
    console.log(target.constructor.name);
</script>


interface HTMLLIElement : HTMLElement {
           attribute DOMString       type;
           attribute long            value;
};


다음은 HTMLAnchroElement이다.

interface HTMLAnchorElement : HTMLElement {
           attribute DOMString       accessKey;
           attribute DOMString       charset;
           attribute DOMString       coords;
           attribute DOMString       href;
           attribute DOMString       hreflang;
           attribute DOMString       name;
           attribute DOMString       rel;
           attribute DOMString       rev;
           attribute DOMString       shape;
           attribute long            tabIndex;
           attribute DOMString       target;
           attribute DOMString       type;
  void               blur();
  void               focus();
};




target.href = 'http://misterharu.com';


# HTMLCollection

<!DOCTYPE html>
<html>
<body>
<ul>
    <li>HTML</li>
    <li>CSS</li>
    <li id="active">JavaScript</li>
</ul>
<script>
console.group('before');
var lis = document.getElementsByTagName('li');
for(var i = 0; i < lis.length; i++){
    console.log(lis[i]);
}
console.groupEnd();
console.group('after');
lis[1].parentNode.removeChild(lis[1]);
for(var i = 0; i < lis.length; i++){
    console.log(lis[i]);
}
console.groupEnd();
</script>
</body>
</html>



# jQuery 

<ul>
    <li>html</li>
    <li>css</li>
    <li>JavaScript</li>
</ul>
<script src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    var li = $('li');
    li.map(function(index, elem){
        console.log(index, elem);
        $(elem).css('color', 'red');
    })
</script>




# jQuery 객체 API
var t = document.getElementById('active');


주요기능

식별자

문서내에서 특정한 엘리먼트를 식별하기 위한 용도로 사용되는 API

Element.classList
Element.className
Element.id
Element.tagName

조회
엘리먼트의 하위 엘리먼트를 조회하는 API

Element.getElementsByClassName
Element.getElementsByTagName
Element.querySelector
Element.querySelectorAll

속성
엘리먼트의 속성을 알아내고 변경하는 API

Element.getAttribute(name)
Element.setAttribute(name, value)
Element.hasAttribute(name);
Element.removeAttribute(name);


# 식별자 API

Element.tagName - 해당 엘리먼트의 태그 이름을 알아낸다. 태그 이름을 변경하지는 못한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active" class="important current">JavaScript</li>
</ul>
<script>
console.log(document.getElementById('active').tagName)
</script>

//Element.id - 문서에서 id는 단 하나만 등장할 수 있는 식별자다. 아래 예제는 id의 값을 읽고 변경하는 방법을 보여준다
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active">JavaScript</li>
</ul>
<script>
var active = document.getElementById('active');
console.log(active.id);
active.id = 'deactive';
console.log(active.id);
</script>

//Element.className - 클래스는 여러개의 엘리먼트를 그룹핑할 때 사용한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active">JavaScript</li>
</ul>
<script>
var active = document.getElementById('active');
// class 값을 변경할 때는 프로퍼티의 이름으로 className을 사용한다.
active.className = "important current";
console.log(active.className);
// 클래스를 추가할 때는 아래와 같이 문자열의 더한다.
active.className += " readed"
</script>


//Element.classList - className에 비해서 훨씬 편리한 사용성을 제공한다.
<ul>
    <li>html</li>
    <li>css</li>
    <li id="active" class="important current">JavaScript</li>
</ul>
<script>
function loop(){
    for(var i=0; i<active.classList.length; i++){
        console.log(i, active.classList[i]);
    }
}
#  클래스를 추가
</script>
<input type="button" value="DOMTokenList" onclick="console.log(active.classList);" />
<input type="button" value="조회" onclick="loop();" />
<input type="button" value="추가" onclick="active.classList.add('marked');" />
<input type="button" value="제거" onclick="active.classList.remove('important');" />
<input type="button" value="토글" onclick="active.classList.toggle('current');" />


//active.classList.add('haru'); 추가
//active.classList.remove('haru'); 삭제
//active.classList.toggle('haru'); 토글(있으면 삭제, 없으면 추가)




# 조회 API
<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked">DOM</li>
            <li class="marked">BOM</li>
        </ul>
    </li>
</ul>
<script>
    var list = document.getElementsByClassName('marked');
    console.group('document');
    for(var i=0; i<list.length; i++){
        console.log(list[i].textContent);
    }
    console.groupEnd();

    console.group('active');
    var active = document.getElementById('active');     
    var list = active.getElementsByClassName('marked');
    for(var i=0; i<list.length; i++){
        console.log(list[i].textContent);
    }
    console.groupEnd();
</script>



# 속성 API

Element.getAttribute(name)
Element.setAttribute(name, value)
Element.hasAttribute(name);
Element.removeAttribute(name);

<a id="target" href="http://opentutorials.org">opentutorials</a>
<script>
var t = document.getElementById('target');
console.log(t.getAttribute('href')); //http://opentutorials.org
t.setAttribute('title', 'opentutorials.org'); // title 속성의 값을 설정한다.
console.log(t.hasAttribute('title')); // true, title 속성의 존재여부를 확인한다.
t.removeAttribute('title'); // title 속성을 제거한다.
console.log(t.hasAttribute('title')); // false, title 속성의 존재여부를 확인한다.
</script>


# 속성과 프로퍼티
<p id="target">
    Hello world
</p>
<script>
    var target = document.getElementById('target');
    // attribute 방식
    target.setAttribute('class', 'important');
    // property 방식
    target.className = 'important';
</script>





<a id="target" href="./demo1.html">ot</a>
<script>
//현재 웹페이지가 http://localhost/webjs/Element/attribute_api/demo3.html 일 때 
var target = document.getElementById('target');
// http://localhost/webjs/Element/attribute_api/demo1.html 
console.log('target.href', target.href);
// ./demo1.html 
console.log('target.getAttribute("href")', target.getAttribute("href"));
</script>



# jQuery 속성 제어 API

<a id="target" href="http://opentutorials.org">opentutorials</a>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
var t = $('#target');
console.log(t.attr('href')); //http://opentutorials.org
t.attr('title', 'opentutorials.org'); // title 속성의 값을 설정한다.
t.removeAttr('title'); // title 속성을 제거한다.
</script>


# attribute와 property
DOM과 마찬가지로 jQuery도 속성(attribute)과 프로퍼티를 구분한다. 속성은 attr, 프로퍼티는 prop 메소드를 사용한다.

<a id="t1" href="./demo.html">opentutorials</a>
<input id="t2" type="checkbox" checked="checked" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
//  현재 문서의 URL이 아래와 같다고 했을 때
//  http://localhost/jQuery_attribute_api/demo2.html
var t1 = $('#t1');
console.log(t1.attr('href')); // ./demo.html 
console.log(t1.prop('href')); // http://localhost/jQuery_attribute_api/demo.html 
 
var t2 = $('#t2');
console.log(t2.attr('checked')); // checked
console.log(t2.prop('checked')); // true
</script>



<div id="t1">opentutorials</div>
<div id="t2">opentutorials</div>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
$('#t1').prop('className', 'important'); 
$('#t2').prop('class', 'current');  
</script>



# jQuery 조회 범위 제한

# selector context
<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked">DOM</li>
            <li class="marked">BOM</li>
        </ul>
    </li>
</ul>
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $( ".marked", "#active").css( "background-color", "red" );
</script>

//실행 결과

<ul>
    <li class="marked">html</li>
    <li>css</li>
    <li id="active">JavaScript
        <ul>
            <li>JavaScript Core</li>
            <li class="marked" style="background-color: red;">DOM</li>
            <li class="marked" style="background-color: red;">BOM</li>
        </ul>
    </li>
</ul>

같은 코딩
$( "#active .marked").css( "background-color", "red" );





# .find()
$( "#active").find('.marked').css( "background-color", "red" );

$('#active').css('color','blue').find('.marked').css( "background-color", "red" );

# find를 너무 복잡하게 사용하면 코드를 유지보수하기 어렵게 된다. 



# Node 관계 API

Node.childNodes
자식노드들을 유사배열에 담아서 리턴한다.
Node.firstChild
첫번째 자식노드
Node.lastChild
마지막 자식노드
Node.nextSibling
다음 형제 노드
Node.previousSibling
이전 형제 노드


<body id="start">
<ul>
    <li><a href="./532">html</a></li> 
    <li><a href="./533">css</a></li>
    <li><a href="./534">JavaScript</a>
        <ul>
            <li><a href="./535">JavaScript Core</a></li>
            <li><a href="./536">DOM</a></li>
            <li><a href="./537">BOM</a></li>
        </ul>
    </li>
</ul>
<script>
var s = document.getElementById('start');
console.log(1, s.firstChild); // #text
var ul = s.firstChild.nextSibling
console.log(2, ul); // ul
console.log(3, ul.nextSibling); // #text
console.log(4, ul.nextSibling.nextSibling); // script
console.log(5, ul.childNodes); //text, li, text, li, text, li, text
console.log(6, ul.childNodes[1]); // li(html)
console.log(7, ul.parentNode); // body
</script>
</body>


# 노드 종류 API

노드 작업을 하게 되면 현재 선택된 노드가 어떤 타입인지를 판단해야 하는 경우가 있다. 이런 경우에 사용할 수 있는 API가 nodeType, nodeName이다. 

Node.nodeType
node의 타입을 의미한다. 
Node.nodeName
node의 이름 (태그명을 의미한다.)

# Node Type
노드의 종류에 따라서 정해진 상수가 존재한다. 아래는 모든 노드의 종류와 종류에 따른 값을 출력하는 예제다.
for(var name in Node){
   console.log(name, Node[name]);
}
# 결과
ELEMENT_NODE 1 
ATTRIBUTE_NODE 2 
TEXT_NODE 3 
CDATA_SECTION_NODE 4 
ENTITY_REFERENCE_NODE 5 
ENTITY_NODE 6 
PROCESSING_INSTRUCTION_NODE 7 
COMMENT_NODE 8 
DOCUMENT_NODE 9 
DOCUMENT_TYPE_NODE 10 
DOCUMENT_FRAGMENT_NODE 11 
NOTATION_NODE 12 
DOCUMENT_POSITION_DISCONNECTED 1 
DOCUMENT_POSITION_PRECEDING 2 
DOCUMENT_POSITION_FOLLOWING 4 
DOCUMENT_POSITION_CONTAINS 8 
DOCUMENT_POSITION_CONTAINED_BY 16 
DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC 32

# 함수가 자기 자신을 호출하는 것을 재귀함수라고 하는데 본 예제는 재귀 함수의 예를 보여준다.







# 노드 종류 API

<!DOCTYPE html>
<html>
<body id="start">
<ul>
    <li><a href="./532">html</a></li> 
    <li><a href="./533">css</a></li>
    <li><a href="./534">JavaScript</a>
        <ul>
            <li><a href="./535">JavaScript Core</a></li>
            <li><a href="./536">DOM</a></li>
            <li><a href="./537">BOM</a></li>
        </ul>
    </li>
</ul>
<script>
function traverse(target, callback){
    if(target.nodeType === 1){
        //if(target.nodeName === 'A')
        callback(target);
        var c = target.childNodes;
        for(var i=0; i<c.length; i++){
            traverse(c[i], callback);       
        }   
    }
}
traverse(document.getElementById('start'), function(elem){
    console.log(elem);
});
</script>
</body>
</html>


# jQuery 노드 변경 API

<div class="target">
    content1
</div>
 
<div class="target">
    content2
</div>
 
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('.target').before('<div>before</div>');
    $('.target').after('<div>after</div>');
    $('.target').prepend('<div>prepend</div>');
    $('.target').append('<div>append</div>');
</script>


# 제거
# 제거와 관련된 API는 remove와 empty가 있다. remove는 선택된 엘리먼트를 제거하는 것이고 empty는 선택된 엘리먼트의 텍스트 노드를 제거하는 것이다.

<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<input type="button" value="remove target 1" id="btn1" />
<input type="button" value="empty target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#target1').remove();
    })
    $('#btn2').click(function(){
        $('#target2').empty();
    })
</script>


# 바꾸기
replaceAll과 replaceWith는 모두 노드의 내용을 교체하는 API이다. replaceWith가 제어 대상을 먼저 지정하는 것에 반해서 replaceAll은 제어 대상을 인자로 전달한다.

<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<input type="button" value="replaceAll target 1" id="btn1" />
<input type="button" value="replaceWith target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('<div>replaceAll</div>').replaceAll('#target1');
    })
    $('#btn2').click(function(){
        $('#target2').replaceWith('<div>replaceWith</div>');
    })
</script>


# 복사
<div class="target" id="target1">
    target 1
</div>
 
<div class="target" id="target2">
    target 2
</div>
 
<div id="source">source</div>
 
<input type="button" value="clone replaceAll target 1" id="btn1" />
<input type="button" value="clone replaceWith target 2" id="btn2" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#source').clone().replaceAll('#target1');
    })
    $('#btn2').click(function(){
        $('#target2').replaceWith($('#source').clone());
    })
</script>



# 이동
<div class="target" id="target1">
    target 1
</div>
 
<div id="source">source</div>
 
<input type="button" value="append source to target 1" id="btn1" />
<script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
<script>
    $('#btn1').click(function(){
        $('#target1').append($('#source'));
    })
</script>



# 문자열로 노드 제어
# innerHTML
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.innerHTML);
    }
    function set(){
        var target = document.getElementById('target');
        target.innerHTML = "<li>JavaScript Core</li><li>BOM</li><li>DOM</li>";
    }
</script>

# outerHTML
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.outerHTML);
    }
    function set(){
        var target = document.getElementById('target');
        target.outerHTML = "<ol><li>JavaScript Core</li><li>BOM</li><li>DOM</li></ol>";
    }
</script>



# innerText, outerText
<ul id="target">
    <li>HTML</li>
    <li>CSS</li>
</ul>
<input type="button" onclick="get();" value="get" />
<input type="button" onclick="set();" value="set" />
<script>
    function get(){
        var target = document.getElementById('target');
        alert(target.innerText);
    }
    function set(){
        var target = document.getElementById('target');
        target.innerText = "<li>JavaScript Core</li><li>BOM</li><li>DOM</li>";
    }
</script>


# insertAdjacentHTML()

<ul id="target">
    <li>CSS</li>
</ul>
<input type="button" onclick="beforebegin();" value="beforebegin" />
<input type="button" onclick="afterbegin();" value="afterbegin" />
<input type="button" onclick="beforeend();" value="beforeend" />
<input type="button" onclick="afterend();" value="afterend" />
<script>
    function beforebegin(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('beforebegin','<h1>Client Side</h1>');
    }
    function afterbegin(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('afterbegin','<li>HTML</li>');
    }
    function beforeend(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('beforeend','<li>JavaScript</li>');
    }
    function afterend(){
        var target = document.getElementById('target');
        target.insertAdjacentHTML('afterend','<h1>Server Side</h1>');
    }
</script>



# 값 API
<ul>
    <li id="target">html</li> 
    <li>css</li>
    <li>JavaScript</li>
</ul>
<script>
    var t = document.getElementById('target').firstChild;
    console.log(t.nodeValue);
    console.log(t.data);
</script>


# 조작 API
appendData()
deleteData()
insertData()
replaceData()
substringData()

<!DOCTYPE html>
<html>
<head>
    <style>
    #target{
        font-size:77px;
        font-family: georgia;
        border-bottom:1px solid black;
        padding-bottom:10px;
    }
    p{
        margin:5px;
    }
    </style>
</head>
<body>
<p id="target">Cording everybody!</p>
<p> data : <input type="text" id="datasource" value="JavaScript" /></p>
<p>   start :<input type="text" id="start" value="5" /></p>
<p> end : <input type="text" id="end" value="5" /></p>
<p><input type="button" value="appendData(data)" onclick="callAppendData()" />
<input type="button" value="deleteData(start,end)" onclick="callDeleteData()" />
<input type="button" value="insertData(start,data)" onclick="callInsertData()" />
<input type="button" value="replaceData(start,end,data)" onclick="callReplaceData()" />
<input type="button" value="substringData(start,end)" onclick="callSubstringData()" /></p>
<script>
    var target = document.getElementById('target').firstChild;
    var data = document.getElementById('datasource');
    var start = document.getElementById('start');
    var end = document.getElementById('end');
    function callAppendData(){
        target.appendData(data.value);
    }
    function callDeleteData(){
        target.deleteData(start.value, end.value);
    }
    function callInsertData(){
        target.insertData(start.value, data.value); 
    }
    function callReplaceData(){
        target.replaceData(start.value, end.value, data.value);
    }
    function callSubstringData(){
        alert(target.substringData(start.value, end.value));
    }
</script>
</body>
</html>


#  요소의 크기와 위치 
#  getBoundingClientRect()
#  offsetParent
# ClientWidth, ClientHeight

<style>
    body{
        padding:0;
        margin:0;
    }
    #target{
        width:100px;
        height:100px;
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
</style>
<div id="target">
    Coding
</div>
<script>
var t = document.getElementById('target');
console.log(t.getBoundingClientRect());
console.log(t.offsetParent);
</script>


# getBoundingClientRect의 width 값을 IE는 제공하지 않는다.


# Viewport
1초에 한번씩 getBoundingClientRect의 top 속성과 window.pageYOffset의 값이 출력된다.

<style>
    body{
        padding:0;
        margin:0;
    }
    div{
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
    #target{
        width:100px;
        height:2000px;
    }
</style>
    <div>
        <div id="target">
            Coding
        </div>
    </div>

<script>
var t = document.getElementById('target');
setInterval(function(){
    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset);
}, 1000)
</script>


# 오래된 브라우저에서는 pageYOffset 대신 scrollTop 속성을 사용해야 한다.


# 문서의 좌표
그럼 문서의 좌표를 알고 싶으면 어떻게 해야 하나? 뷰포트의 좌표에 스크롤된 정도를 더해서 알 수 있다. 아래와 같이 코드를 조금 수정했다

setInterval(function(){
    console.log('getBoundingClientRect : ', t.getBoundingClientRect().top, 'pageYOffset:', window.pageYOffset, 'document y:', t.getBoundingClientRect().top+window.pageYOffset);
}, 1000)


# 스크롤
<style>
    body{
        padding:0;
        margin:0;
    }
    div{
        border:50px solid #1065e6;
        padding:50px;
        margin:50px;
    }
    #target{
        width:100px;
        height:2000px;
    }
</style>
<input type="button" id="scrollBtn" value="scroll(0, 1000)" />
<script>
    document.getElementById('scrollBtn').addEventListener('click', function(){
        window.scrollTo(0, 1000);
    })
</script>
<div>
    <div id="target">
        Coding
    </div>
</div>



1920*1080

# 스크린의 크기
window.inner*은 뷰포트의 크기를 나타내고, screen.*은 스크린의 크기를 나타낸다.

<script>
console.log('window.innerWidth:', window.innerWidth, 'window.innerHeight:', window.innerHeight);
console.log('screen.width:', screen.width, 'screen.height:', screen.height);
</script>


# 이벤트란?
이벤트(event)는 어떤 사건을 의미한다. 브라우저에서의 사건이란 사용자가 클릭을 했을 '때', 스크롤을 했을 '때', 필드의 내용을 바꾸었을 '때'와 같은 것을 의미한다. 

<!DOCTYPE html>
<html>
<body>
    <input type="button" onclick="alert(window.location)" value="alert(window.href)" />
    <input type="button" onclick="window.open('bom.html')" value="window.open('bom.html')" />
</body>
</html>

onclick 속성의 자바스크립트 코드(alert(window.location))는 사용자가 이 버튼을 클릭 했을 '때' 실행된다. 즉 js 개발자는 어떤 일이 발생했을 때 실행 되어야 하는 코드를 등록하고, 브라우저는 그 일이 발생했을 때 등록된 코드를 실행하게 된다. 이러한 방식을 이벤트 프로그래밍이라고 한다.

# event target
<input type="button" onclick="alert(window.location)" value="alert(window.href)" />

# event type
이벤트의 종류를 의미한다. 위의 예제에서는 click이 이벤트 타입이다. 그 외에도 scroll은 사용자가 스크롤을 움직였다는 이벤트이고, mousemove는 마우스가 움직였을 때 발생하는 이벤트이다.

# event handler
이벤트가 발생했을 때 동작하는 코드를 의미한다. 위의 예제에서는 alert(window.location)이 여기에 해당한다.


# inline
인라인(inline) 방식으로 이벤트를 등록하는 방법을 알아보자. 인라인 방식은 이벤트를 이벤트 대상의 태그 속성으로 지정하는 것이다. 다음은 버튼을 클릭했을 때 Hello world를 경고창으로 출력한다.

<input type="button" onclick="alert('Hello world');" value="button" />
이벤트가 발생한 대상을 필요로하는 경우 this를 통해서 참조할 수 있다.


<!--자기 자신을 참조하는 불편한 방법-->
<input type="button" id="target" onclick="alert('Hello world, '+document.getElementById('target').value);" value="button" />
<!--this를 통해서 간편하게 참조할 수 있다-->
<input type="button" onclick="alert('Hello world, '+this.value);" value="button" />

인라인 방식은 태그에 이벤트가 포함되기 때문에 이벤트의 소재를 파악하는 것이 편리하다. 하지만 정보인 HTML과 제어인 JavaScript가 혼재된 형태이기 때문에 바람직한 방법이라고 할수는 없다. 


# 프로퍼티 리스너

<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>MisterHaru Clan Scrim</title>
        <style>
    
        </style>
    </head>
    <body>
        <input type="button" id="target" value="button" />

        <script>
            var t = document.getElementById('target');
            t.onclick = function(event){
                var event = event || window.event;
                //alert('Hello World, '+event.target.value)
                console.dir(event);
                console.log(event.target);
            }
        </script>
    </body>
</html>

# 이벤트 객체
이벤트가 실행된 맥락의 정보가 필요할 때는 이벤트 객체를 사용한다. 이벤트 객체는 이벤트가 실행될 때 이벤트 핸들러의 인자로 전달된다. 
<body>
    <input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.onclick = function(event){
        alert('Hello world, '+event.target.value)
    }
</script>

//ie8 이하 버전에서는 이벤트 객체를 핸들러의 인자가 아니라 전역객체의 event 프로퍼티로 제공한다. 또한 target 프로퍼티도 지원하지 않는다. 아래는 이 문제를 해소하기 위한 코드다.
<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.onclick = function(event){
        var event = event || window.event;
        var target = event.target || event.srcElement;
        alert('Hello world, '+target.value)
    }
</script>


# addEventListener()
addEventListener은 이벤트를 등록하는 가장 권장되는 방식이다. 이 방식을 이용하면 여러개의 이벤트 핸들러를 등록할 수 있다.


<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.addEventListener('click', function(event){
        alert('Hello world, '+event.target.value);
    });
</script>


이 방식은 ie8이하에서는 호환되지 않는다. ie에서는 attachEvent 메소드를 사용해야 한다. 

var t = document.getElementById('target');
if(t.addEventListener){
    t.addEventListener('click', function(event){
        alert('Hello world, '+event.target.value);
    }); 
} else if(t.attachEvent){
    t.attachEvent('onclick', function(event){
        alert('Hello world, '+event.target.value);
    })
}

이 방식의 중요한 장점은 하나의 이벤트 대상에 복수의 동일 이벤트 타입 리스너를 등록할 수 있다는 점이다. 

<input type="button" id="target" value="button" />
<script>
    var t = document.getElementById('target');
    t.addEventListener('click', function(event){
        alert(1);
    });
    t.addEventListener('click', function(event){
        alert(2);
    });
</script>

이벤트 객체를 이용하면 복수의 엘리먼트에 하나의 리스너를 등록해서 재사용할 수 있다. 

<input type="button" id="target1" value="button1" />
<input type="button" id="target2" value="button2" />
<script>
    var t1 = document.getElementById('target1');
    var t2 = document.getElementById('target2');
    function btn_listener(event){
        switch(event.target.id){
            case 'target1':
                alert(1);
                break;
            case 'target2':
                alert(2);
                break;
        }
    }
    t1.addEventListener('click', btn_listener);
    t2.addEventListener('click', btn_listener);
</script>



## 이벤트 전파(버블링과 캡처링)

<html>
    <head>
        <style>
            html{border:5px solid red;padding:30px;}
            body{border:5px solid green;padding:30px;}
            fieldset{border:5px solid blue;padding:30px;}
            input{border:5px solid black;padding:30px;}
        </style>
    </head>
    <body>
        <fieldset>
            <legend>event propagation</legend>
            <input type="button" id="target" value="target">          
        </fieldset>
        <script>
        function handler(event){
            var phases = ['capturing', 'target', 'bubbling']
            console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
        }
        document.getElementById('target').addEventListener('click', handler, true);
        document.querySelector('fieldset').addEventListener('click', handler, true);
        document.querySelector('body').addEventListener('click', handler, true);
        document.querySelector('html').addEventListener('click', handler, true);
        </script>
    </body>
</html>

//실행결과
INPUT HTML capturing
INPUT BODY capturing
INPUT FIELDSET capturing
INPUT INPUT target

이벤트가 부모에서부터 발생해서 자식으로 전파되고 있다. 이러한 방식을 capturing이라고 한다

document.getElementById('target').addEventListener('click', handler, false);
document.querySelector('fieldset').addEventListener('click', handler, false);
document.querySelector('body').addEventListener('click', handler, false);
document.querySelector('html').addEventListener('click', handler, false);

//아래처럼 코드를 변경해보자.
function handler(event){
    var phases = ['capturing', 'target', 'bubbling']
    console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
}
function stophandler(event){
    var phases = ['capturing', 'target', 'bubbling']
    console.log(event.target.nodeName, this.nodeName, phases[event.eventPhase-1]);
    event.stopPropagation();
}
document.getElementById('target').addEventListener('click', handler, false);
document.querySelector('fieldset').addEventListener('click', handler, false);
document.querySelector('body').addEventListener('click', stophandler, false);
document.querySelector('html').addEventListener('click', handler, false);


//실행결과
INPUT INPUT target
INPUT FIELDSET bubbling
INPUT BODY bubbling

//stopPropagation


# 기본동작의 취소

//inline
이벤트의 리턴값이 false이면 기본 동작이 취소된다.

<p>
    <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
</p>
<p>
    <a href="http://opentutorials.org" onclick="if(document.getElementById('prevent').checked) return false;">opentutorials</a>
</p>
<p>
    <form action="http://opentutorials.org" onsubmit="if(document.getElementById('prevent').checked) return false;">
            <input type="submit" />
    </form>
</p>


//property 방식
리턴 값이 false이면 기본동작이 취소된다

<p>
    <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
</p>
<p>
    <a href="http://opentutorials.org">opentutorials</a>
</p>
<p>
    <form action="http://opentutorials.org">
            <input type="submit" />
    </form>
</p>
<script>
    document.querySelector('a').onclick = function(event){
        if(document.getElementById('prevent').checked)
            return false;
    };
    
    document.querySelector('form').onclick = function(event){
        if(document.getElementById('prevent').checked)
            return false;
    };

</script>

//addEventListener 방식
이 방식에서는 이벤트 객체의 preventDefault 메소드를 실행하면 기본 동작이 취소된다.

<p>
            <label>prevent event on</label><input id="prevent" type="checkbox" name="eventprevent" value="on" />
        </p>
        <p>
            <a href="http://opentutorials.org">opentutorials</a>
        </p>
        <p>
            <form action="http://opentutorials.org">
                    <input type="submit" />
            </form>
        </p>
        <script>
            document.querySelector('a').addEventListener('click', function(event){
                if(document.getElementById('prevent').checked)
                    event.preventDefault();
            });
            
            document.querySelector('form').addEventListener('submit', function(event){
                if(document.getElementById('prevent').checked)
                    event.preventDefault();
            });

        </script>


# 이벤트 타입
	
<input type="button" onclick="alert(1);" />

//폼
//submit
submit은 폼의 정보를 서버로 전송하는 명령인 submit시에 일어난다.

form 태그에 적용된다.

아래 예제는 전송 전에 텍스트 필드에 값이 입력 되었는지를 확인한다. 만약 값이 입력되지 않았다면 전송을 중단한다.

<form id="target" action="result.html">
    <label for="name">name</label> <input id="name" type="name" />
    <input type="submit" />
</form>
<script>
var t = document.getElementById('target');
t.addEventListener('submit', function(event){
    if(document.getElementById('name').value.length === 0){
        alert('Name 필드의 값이 누락 되었습니다');
        event.preventDefault();
    }
});
</script>


# event.preventDefault();

//change
change는 폼 컨트롤의 값이 변경 되었을 때 발생하는 이벤트다.

input(text,radio,checkbox), textarea, select 태그에 적용된다.

<p id="result"></p>
<input id="target" type="name" />
<script>
var t = document.getElementById('target');
t.addEventListener('change', function(event){
    document.getElementById('result').innerHTML=event.target.value;
});
</script>


//blur, focus
focus는 엘리먼트에 포커스가 생겼을 때, blur은 포커스가 사라졌을 때 발생하는 이벤트다. 

다음 태그를 제외한 모든 태그에서 발생한다. <base>, <bdo>, <br>, <head>, <html>, <iframe>, <meta>, <param>, <script>, <style>, <title>

<input id="target" type="name" />
<script>
var t = document.getElementById('target');
t.addEventListener('blur', function(event){
    alert('blur');  
});
t.addEventListener('focus', function(event){
    alert('focus'); 
});
</script>



# 문서 로딩
웹페이지를 프로그래밍적으로 제어하기 위해서는 웹페이지의 모든 요소에 대한 처리가 끝나야 한다. 이것을 알려주는 이벤트가 load, DOMContentLoaded이다.

아래 코드의 실행결과는 null이다. <p id="target">Hello</p>가 로딩되기 전에 자바스크립트가 실행되었기 때문이다.

<html>
    <head>
        <script>
            window.addEventListener('load', function(){
                console.log('load');
            })
            window.addEventListener('DOMContentLoaded', function(){
                console.log('DOMContentLoaded');
            })
        </script>
    </head>
    <body>
        <p id="target">Hello</p>
    </body>
</html>


# 마우스
//이벤트 타입
웹브라우저는 마우스와 관련해서 다양한 이벤트 타입을 지원한다.

click
클릭했을 때 발생하는 이벤트. 
dblclick
더블클릭을 했을 때 발생하는 이벤트
mousedown
마우스를 누를 때 발생
mouseup
마우스버튼을 땔 때 발생
mousemove
마우스를 움직일 때
mouseover
마우스가 엘리먼트에 진입할 때 발생
mouseout
마우스가 엘리먼트에서 빠져나갈 때 발생
contextmenu
컨텍스트 메뉴가 실행될 때 발생


# //키보드 조합  https://www.opentutorials.org/

<!DOCTYPE html>
<html>
<head>
    <title></title>
    <style>li {padding:10px; list-style: none}</style>
</head>

<body>

    
    <style>
        body{
            padding:0;
            margin:0;
        }
        div{
            border:50px solid #1065e6;
            padding:50px;
            margin:50px;
        }
        #target{
            width:100px;
            height:2000px;
        }
    </style>
    <input type="button" id="scrollBtn" value="scroll(0, 1000)" />
    <script>
        document.getElementById('scrollBtn').addEventListener('click', function(){
            window.scrollTo(0, 1000);
        })
    </script>
    <div>
        <div id="target">
            Coding
        </div>
    </div>
</body>
</html>



# 코드잇 자바스크립트 수업 내용

# 함수

function expressMultiplication(a, b) {
  console.log(String(a) + " * " + String(b) + " = " + String(a * b));
}
// 테스트 코드
expressMultiplication(3, 4);
expressMultiplication(3, 2);
expressMultiplication(7, 5);
expressMultiplication(8, 9);
expressMultiplication(5, 5);
expressMultiplication(9, 9);

</> 실행 결과
3 * 4 = 12
3 * 2 = 6
7 * 5 = 35
8 * 9 = 72
5 * 5 = 25
9 * 9 = 81


# return
return: 돌려주다
미국 단위인 '인치(inch)'를 '센티미터(cm)'로 변환 시켜주는 함수 inchToCentimeter를 작성했습니다.

(1)  function inchToCentimeter(inch) {
(2)      var centimeter = inch * 2.54;  // 1 inch = 2.54cm
(3)      return centimeter;             // cm로 계산한 결괏값 돌려주기
(4)  }
(5)  
(6)  var result1 = inchToCentimeter(2); // 2 inch를 cm로 바꾼 값
(7)  var result2 = inchToCentimeter(3); // 3 inch를 cm로 바꾼 값
(8) 
(9)  console.log(result1);
(10) console.log(result2);
(11) console.log(inchToCentimeter(1) + inchToCentimeter(5));
5.08
7.62
15.24
코드를 보면 return이라는 게 있죠? 'return'은 한국말로 '돌려주다'입니다. 누가 누구에게 무엇을 돌려준다는 얘기일까요?

6번 줄을 보시면 inchToCentimeter 함수가 호출됩니다.
inch의 값으로 2가 들어가기 때문에 centimeter에는 2 * 2.54인 5.08이 들어갑니다.
3번 줄에서 return centimeter를 하기 때문에 inchToCentimeter 함수는 5.08을 '돌려주게' 됩니다.
함수를 호출한 부분인 inchToCentimeter(2)는 5.08을 '돌려받아서', inchToCentimeter(2)가 5.08로 대체된다고 보시면 됩니다. 따라서 result1에는 5.08이 저장됩니다.
7번 줄에도 함수 호출이 있고, 11번 줄에는 함수 호출이 두 개가 있습니다. 콘솔에 7.62와 15.24가 출력되는 과정 이해 되시나요?


======

function calculateRectangleArea(x, y) {
    var ares = x * y;
    return ares;
}


// 테스트 코드
var area1 = calculateRectangleArea(3, 4); // 가로 3, 세로 4인 직사각형의 넓이 계산
var area2 = calculateRectangleArea(5, 8); // 가로 5, 세로 8인 직사각형의 넓이 계산
var area3 = calculateRectangleArea(7, 2); // 가로 7, 세로 2인 직사각형의 넓이 계산

console.log('Area1: ' + area1 + ', Area2: ' + area2 + ', Area3: ' + area3);


# 정답
function calculateRectangleArea(x, y) {
    return x * y;
}

# 형 변환 함수
우리도 이미 내장 함수를 쓴 적이 있습니다.

바로 형 변환 함수!

String(3);
Number('7');
첫 줄의 함수 이름은 String이고, 파라미터로 숫자 3을 받고, 문자열 '3'을 리턴해주는 거죠. 두 번째 줄의 함수 이름은 Number이고, 파라미터로 문자열 '7'을 받고 숫자 7을 리턴해줍니다.

이 두 함수는 분명 우리가 선언을 안 했는데도 잘 작동하네요. 자바스크립트 내부에서 미리 선언을 해준 것입니다. 숫자를 문자열로, 또는 문자열을 숫자로 바꾸는 함수는 누구에게나 필요할 것 같아서 이미 구현되어 있습니다.

# parseInt 함수
Number 함수와 비슷한 parseInt라는 함수도 있는데요. Number와는 조금 다르게, 파라미터가 '100세'처럼 숫자랑 문자가 섞여 있으면 숫자만 꺼내서 변환시켜줍니다.

parseInt('100세');
parseInt('세100');
100
NaN
하지만 보시다시피 숫자가 앞에 있어야 제대로 작동합니다. parseInt('세100')을 했을 때 나오는 NaN은 'Not a Number(숫자가 아니다)'의 약자입니다.

# 그 외의 내장 함수
alert, prompt, console.log도 자바스크립트에서 미리 준비해둔 함수들입니다. 내장 함수를 잘 알아두면 우리의 코딩 시간을 단축할 수 있겠죠?

이 외에도 다양한 내장 함수가 준비되어있지만 사용법은 동일합니다. 보통은 필요할 때 즉석에서 찾아보고 활용하는 경우가 많습니다.


String()	숫자를 문자열로 변환해주는 함수.
Number()	문자열을 숫자로 변환해주는 함수.
parseInt()	문자열 안에서 정수를 뽑아주는 함수.
parseFloat()	문자열 안에서 숫자(소수 포함)를 뽑아주는 함수.
alert()	사용자에게 메시지를 띄워주는 함수.
prompt()	사용자에게 메시지를 띄우고, 문자열을 입력받는 함수.
confirm()	사용자에게 메시지를 띄우고, 확인과 취소 중 하나를 누르게 하는 함수.





# if문
<script>
var inputNumber = window.prompt("한 자리 숫자를 적어주세요.");

if (inputNumber === '7') {
    alert('Lucky!');
}   else if (inputNumber === '0') {
    alert('Zero');
}   else if (inputNumber === '1') {
    alert('One');
}   else {
    alert('Unlucky!');
}
</script>

# 14가 6의 배수인지 확인
var num = 14;
if (num % 2 === 0 && num % 3 === 0) {
    console.log(num + '는 6의 배수입니다.');
} else {
    console.log(num + '는 6의 배수가 아닙니다.');
}

## 숫자를 입력 받을수 있도록 재 코딩
var inputNumber = window.prompt("6의 배수를 적어주세요.");

if (inputNumber % 2 === 0 && inputNumber % 3 === 0) {
    console.log(inputNumber + '는 6의 배수입니다.');
} else {
    console.log(inputNumber + '는 6의 배수가 아닙니다.');
}



<script>

function whatShouldICallYou(myAge, myGender, yourAge, yourGender) {
    // 나의 나이, 나의 성별, 상대방의 나이, 상대방의 성별
    // 총 4개의 정보를 활용해서 호칭을 결정해보세요.
if (myAge === yourAge){
    return "친구";
} else if (myAge > yourAge) {
    if (yourGender === "male") {
    return "남동생";
} else if (yourGender === "female") {
    return "여동생";
} 
} else if (myGender === "male") {
    if (yourGender === "male") {
    return "형";
    } else if (yourGender === "female") {
    return "누나";
    }
} else if (myGender === "female") {
    if (yourGender === "male") {
    return "오빠";
    } else if (yourGender === "female") {
    return "언니";
    }
}
}
// 테스트 코드
var result1 = whatShouldICallYou(23, 'male', 25, 'female');
var result2 = whatShouldICallYou(21, 'female', 21, 'female');
var result3 = whatShouldICallYou(25, 'female', 22, 'male');

console.log(result1);
console.log(result2);
console.log(result3);

</script>


# switch문
// switch 문 뒤에 break를 꼭 넣어 줘야 한다. 그렇지 않으면 뒤쪽에 모두 alert가 표시 된다.


switch (inputNumber) {
    case '0':
        alert('Zero!');
        break;
    case '1':
        alert('Oneo!');
        break;
    case '7':
        alert('Lucky!');
        break;
    default:
        alert('Unlucky!');
        break;
}


# 파이썬은  switch문이 없으므로 if문으로 작성해야 한다. 자바스크립트에서만 스위치문 사용

# for반복문

for (초기화부분; 조건부분; 추가동작부분) {
    동작부분
}

for ( let i = 1; i <= 10; i++) {
    console.log('${i} 미스터하루');
}




# 문제 : 주어진 높이(height)에 맞게 *로 삼각형을 그려주는 함수 printTriangle을 써봅시다. 출력 결과는 아래를 참고해주세요.


높이: 5
*
**
***
****
*****
높이: 3
*
**
***
높이: 1
*


function printTriangle(height) {
    // 이 함수 안에서 console.log를 직접 사용하여
    // 직접 출력까지 완료해야 합니다.
    // 이 함수는 return 값이 없습니다.
    text = '';
    for(var i = 0; i < height; i = i + 1){
        text = text + '*';
        console.log(text);
    }
}

// 테스트 코드
console.log('높이: 5');
printTriangle(5);

console.log('높이: 3');
printTriangle(3);

console.log('높이: 1');
printTriangle(1);



# 문제

1등만 기억하는 세상을 타파하기 위해, 2등을 찾아보는 프로그램을 만들기로 했습니다.

파라미터로 배열 arr을 받고, arr에서 두 번째로 큰 숫자를 리턴시켜주는 함수 getSecondBiggestNumber를 작성해주세요.

코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

7
80
6


function getSecondBiggestNumber(arr) {
    // 코드를 작성하세요.
    var first = arr[0];
    var second = arr[1];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] > first) {
            second = first;
            first = arr[i];
        } else if (arr[i] > second) {
            second = arr[i]
        }
    }
    return second;
}

// 테스트 코드
console.log(getSecondBiggestNumber([4, 7, 2, 1, 9, 3, 6, 5]));
console.log(getSecondBiggestNumber([80, 2, 44, 21, 92, 3, 51]));
console.log(getSecondBiggestNumber([4, 7, 6, 5]));


# for of반복문

var brand = ['NIKE', 'ADIDA', 'REEBOK'];

for (var value of brands) {
    console.log(value);
}

=====

for (var [변수] of brands) {
    console.log(변수);
}



for...in문과 for...of문의 차이
우선 for...in문과 for...of문의 차이부터 살펴봅시다.

var arr =  ['Americano', 'Latte', 'Tea'];

// for...of
for (var v of arr) {
  console.log(v);
}

console.log('---');

// for...in
for (var k in arr) {
  console.log(k);
}
Americano
Latte
Tea
---
0
1
2
차이점이 보이시나요?

배열은 여러 개의 index-value 쌍으로 이루어졌다고 볼 수 있는데요. 위 코드의 arr배열의 경우에 index는 0, 1, 2이고, value는 'Americano', 'Latte', 'Tea'입니다.

출력된 결과를 보시면 알 수 있듯 for...of문은 배열의 value에 직접 접근하는 반면, for...in문은 index에 접근합니다.

for...in문으로 value에 접근하기 위해서는 이렇게 바꿔줘야겠죠?

// for...in
for (var k in arr) {
  console.log(arr[k]);
}
Americano
Latte
Tea



# while 반복문
var brands = ['apple', 'coca-cola', 'starbucks', 'amazon', 'disney', 'BMW'];

var i = 0;

while (i < 6) {
    console.log(brands[i]);
    i++
}


# break문
만약 while문의 조건부분과 상관 없이 반복문에서 나오고 싶으면 break문을 쓰면 됩니다.

var i = 100;

while (true) {
    // i가 23의 배수면 반복문을 끝냄
    if (i % 23 == 0) {
        break;
    }
    i = i + 1;
}

console.log(i);

115


# continue문
만약 현재 진행되고 있는 수행부분을 중단시키고 바로 조건부분을 다시 확인하고 싶으면 continue문을 쓰면 됩니다.

var i = 0;

while (i < 15) {
    i = i + 1;

    // i가 홀수면 console.log(i) 안하고 바로 조건부분으로 돌아감
    if (i % 2 == 1) {
        continue;
    }
    console.log(i);
}


2
4
6
8
10
12
14

# 로그인 모듈
사용자에게 아이디와 비밀번호를 입력받아서 '로그인' 시키는 모듈을 아래 두 가지 방법으로 만들어봅시다:

1. 다섯 번의 기회만 주는 모듈
2. 성공할 때까지 기회를 무제한으로 주는 모듈

# 횟수 제한 (for문)
// 최대 다섯 번의 기회를 준다
for (var i = 0; i < 5; i++) {
  // 아이디와 비밀번호를 입력 받는다
  var id = window.prompt("아이디를 입력하세요");
  var password = window.prompt("비밀번호를 입력하세요");

  if (id === 'codeit' && password === '4321') {
    console.log('환영합니다. ' + id + '님.');
    break;
  } else {
    console.log('아이디와 비밀번호가 일치하지 않습니다.');
  }
}

# 무제한 (while문)

// 로그인 성공 여부를 보관하는 변수
var login = false;

// 로그인에 성공할 때까지 반복
while (!login) {
  // 아이디와 비밀번호를 입력 받는다
  var id = window.prompt("아이디를 입력하세요");
  var password = window.prompt("비밀번호를 입력하세요");

  if (id === 'codeit' && password === '4321') {
    console.log('환영합니다. ' + id + '님.');
    login = true;
  } else {
    console.log('아이디와 비밀번호가 일치하지 않습니다.');
  }
}

//for문과 while문의 차이를 눈치 채셨나요? 물론 이분법적으로 나눌 수 있는 얘기는 아니지만, 일반적으로 반복 횟수가 예측 가능할 때에는 for문을 사용하는 것이 더 눈에 잘 들어옵니다. 반대로 반복 횟수를 예측할 수 없으면 while문을 쓰는 것이 더 적합한 경우가 많겠죠?



#문제

0! = 1
1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
6! = 6 * 5 * 4 * 3 * 2 * 1 = 720
파라미터로 정수 n을 받고 n!을 계산해서 리턴해주는 함수 factorial을 작성해주세요.

코드를 잘 작성하셨다면 아래와 같이 출력되어야 합니다.
3628800
120
6
1


function factorial(num) {
    var factorialValue = 1;
    // 코드를 작성하세요.
    if (num > 1) {
        for(var i = 1; i <= num; i++){
            factorialValue = factorialValue * i;
        }
    }
    return factorialValue;
}

console.log(factorial(10));
console.log(factorial(5));
console.log(factorial(3));
console.log(factorial(0));



더 간단하게 작성

function factorial(n) {
    var result = 1;

    for (var i = 1; i <= n; i++) {
        result = result * i;
    }
    return result;
}

// 테스트 코드
console.log(factorial(10));
console.log(factorial(5));
console.log(factorial(3));
console.log(factorial(0));


# 배열 만들기 I
배열에 push 메소드를 사용하면 배열 마지막 칸에 값이 추가됩니다
var arr = [2, 3, 5, 7];
arr.push(11);
console.log(arr);

[2, 3, 5, 7, 11]



# 문제
범위의 시작 지점(start), 끝 지점(end), 그리고 증가폭(step)을 파라미터로 받고, 그에 해당하는 배열을 리턴해주는 함수 range를 작성해주세요.


function range(start, end, step) {
    var arr = [];
    var idx = 0;

    if (start < end) {
        for (var i = start; i < end; i += step) {
            arr[idx] = i;
            idx++;
        }
    } else {
        for (var i = start; i > end; i += step) {
            arr[idx] = i;
            idx++;
        }
    }
    return arr;
}
// 테스트 코드
console.log(range(1, 10, 1));
console.log(range(-1, 10, 3));
console.log(range(10, -10, -4));

[1, 2, 3, 4, 5]
[3, 5, 7, 9]
[10, 6, 2, -2, -6]


# 문제
아래의 조건에 맞게 원래의 배열로 돌려놓는 함수 restoreArray를 만들어주세요.

2중 배열이 아닌, 하나의 배열로 통합한다.
배열 안의 배열에 있는 숫자들은 순서를 뒤바꾼다.
[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4, 5, 6 ]

[
  3,  5, 4, 6,
  7, 10, 9, 8
]
먼저 2중 배열을 하나의 배열로 만들어봅시다.
for문을 사용하여 arr의 각 요소에 대해 length를 확인하고, 그 length만큼 다시 반복해주면서 returnArr에 추가합니다.

var arr1 = [[2, 1], [4, 3]];
var arr2 = [[3, 2, 1], [5, 4], [6]];
var arr3 = [[3], [4, 5], [6], [7], [8, 9, 10]];

function restoreArray(arr) {
    var returnArr = [];
    var idx = 0;

    for (var i = 0; i < arr.length; i++) {
        for (var j = 0; j < arr[i].length; j++) {
            returnArr[idx] = arr[i][j];
            idx++;
        }
    }
    return returnArr;
}

console.log(restoreArray(arr1));
console.log(restoreArray(arr2));
console.log(restoreArray(arr3));

위와 같이 작성하면 하나의 배열로 만들었지만, 순서가 뒤집히지 않았습니다.
위의 코드를 조금 더 고쳐봅시다.

두 번째 for문에서, j를 0부터 arr[i].length까지 증가시키는 것이 아니라 arr[i].length부터 0까지 감소시키면 뒤집힌 순서로 추가할 수 있습니다.

var arr1 = [[2, 1], [4, 3]];
var arr2 = [[3, 2, 1], [5, 4], [6]];
var arr3 = [[3], [4, 5], [6], [7], [8, 9, 10]];

function restoreArray(arr) {
    var returnArr = [];
    var idx = 0;

    for (var i = 0; i < arr.length; i++) {
        for (var j = arr[i].length - 1; j >= 0; j--) {
            returnArr[idx] = arr[i][j];
            idx++;
        }
    }
    return returnArr;
}

console.log(restoreArray(arr1));
console.log(restoreArray(arr2));
console.log(restoreArray(arr3));

[ 1, 2, 3, 4 ]
[ 1, 2, 3, 4, 5, 6 ]

[
  3,  5, 4, 6,
  7, 10, 9, 8
]

# 문제
// 코드를 입력해 주세요.
function teraToGiga(volume) {
  console.log(volume + 'TB는');
  console.log(volume * 1024 + 'GB 입니다.');
}

function teraToMega(volume) {
  console.log(volume + 'TB는');
  console.log(volume * 1024 * 1024 + 'MB 입니다.');
}

// TB -> GB 테스트
teraToGiga(2);

// TB -> MB 테스트
teraToMega(2);


function score(kill, win){
    result = kill + wing;
    console.log(result);
}
score(10,5);


# then 메소드 제대로 익히기

Promise 객체의 then 메소드를 제대로 이해해야 Promise Chaining을 잘 할 수 있습니다. then 메소드가 리턴한 Promise 객체가 그 콜백의 리턴값에 따라 어떻게 되는지, 이전 노트에서 배운 각각의 케이스를 코드잇 실행기에 준비해 두었는데요. 지금 각 케이스별로 아래와 같이 나뉘어 있습니다.

Case(1) : 콜백에서 Promise 객체를 리턴
Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴
Case(3) : 콜백에서 아무것도 리턴하지 않음
Case(4) : 콜백 실행 중 에러 발생 
Case(5) : 콜백이 실행되지 않음

fetch('https://jsonplaceholder.typicode.com/users')
  .then((response) => {
  // return response.json(); // <- Case(1)
   //return 10; // <- Case(2)
    // // <- Case(3)
    //throw new Error('failed'); // <- Case(4)
})
  .then((result) => {
    console.log(result);
  });


Promise 객체의 then 메소드를 제대로 이해해야 Promise Chaining을 잘 할 수 있습니다. then 메소드가 리턴한 Promise 객체가 그 콜백의 리턴값에 따라 어떻게 되는지, 이전 노트에서 배운 각각의 케이스를 코드잇 실행기에 준비해 두었는데요. 지금 각 케이스별로 아래와 같이 나뉘어 있습니다.

Case(1) : 콜백에서 Promise 객체를 리턴
Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴
Case(3) : 콜백에서 아무것도 리턴하지 않음
Case(4) : 콜백 실행 중 에러 발생 
Case(5) : 콜백이 실행되지 않음

각 케이스별 코드 앞에 있는 주석을 선택적으로 해제 및 적용해가면서 각각 어떤 결과가 출력되는지 살펴보세요.

# 해설
then 메소드가 리턴한 Promise 객체를 A라고 했을 때, 각 경우에 A는 다음과 같은 상태와 결과를 갖게 됩니다.

Case(1) : 콜백에서 Promise 객체를 리턴

콜백이 리턴한 Promise  객체를 B라고 하면 A는 B와 동일한 상태와 결과를 갖게 됩니다. 나중에 B가 fulfilled 상태가 되면 A도 똑같이 fulfilled 상태가 되고 동일한 작업 성공 결과를, 나중에 B가 rejected 상태가 되면 A도 똑같이 rejected 상태가 되고 동일한 작업 실패 정보를 가진다는 뜻입니다.

Case(2) : 콜백에서 Promise 객체가 아닌 일반적인 값을 리턴

A는 fulfilled 상태가 되고, 해당 리턴값을 작업 성공 결과로 갖게 됩니다.

Case(3) : 콜백에서 아무것도 리턴하지 않음

자바스크립트에서는 함수가 아무것도 리턴하지 않으면 undefined를 리턴한 것으로 간주합니다. 
따라서 A는 fulfilled 상태가 되고, undefined를 작업 성공 결과로 갖게 됩니다.

Case(4) : 콜백 실행 중 에러 발생

A는 rejected 상태가 되고, 해당 에러 객체를 작업 실패 정보로 갖게 됩니다.

Case(5) : 콜백이 실행되지 않음

A는 호출된 then 메소드의 주인에 해당하는, 이전 Promise 객체와 동일한 상태와 결과를 가집니다.

Promise 객체 공부는 then 메소드가 그 처음과 끝이라고 해도 될 정도로, then 메소드를 정확하게 이해하는 것이 중요합니다. 지금 각각의 케이스를 잘 기억해 두면, 앞으로의 내용을 훨씬 더 쉽게 이해할 수 있을 겁니다.


Promise 객체는 크게 3가지 중 하나의 상태를 가집니다. 작업이 아직 완료되지 않았으면 pending 상태, 작업이 성공적으로 잘 완료되었다면 fulfilled 상태, 작업이 실패했다면 rejected 상태가 되는데요. 즉, 최초의 pending 상태에서 fulfilled 상태 또는 rejected 상태로 변하는 겁니다. 참고로, pending 상태에서 한번 fulfilled 상태 또는 rejected 상태가 되면 다시 다른 상태를 가질 수 없습니다.

# 문제
만약 인터넷이 안되는 상황에서 아래 코드를 실행한다면 무슨 문자열이 출력될까요?
fetch('https://jsonplaceholder.typicode.com/')
  .then((result) => { console.log('success'); }, (error) => { console.log('fail'); });

인터넷이 안 되는 상태에서는 fetch 함수의 작업이 실패하겠죠? 그럼 fetch 함수가 리턴한 Promise 객체가 rejected 상태가 되고, 이렇게 Promise 객체가 rejected 상태가 되면. then 메소드의 두 번째 콜백이 실행됩니다. 잘 기억하세요!

자바스크립트에서는 함수가 아무것도 리턴하지 않으면, undefined를 리턴한 것으로 봅니다. 따라서 콜백에서 아무것도 리턴하지 않아도 undefined를 리턴한 것으로 보아서, A는 fulfilled 상태가 되고, 작업 성공 결과로 undefined를 갖게 됩니다. Promise Chaining을 완벽하게 이해하려면 then 메소드에 관한 이런 규칙들을 제대로 이해해야 합니다.


#  catch 메소드

fetch('https://jsonplaceholder.typicode.com/')
    .then((result) => response.text(), (error) => { console.log(error); })
    .then((result) => { console.log(result); });

# then 메소드와 catch 메소드의 역할이 동일.
fetch('https://jsonplaceholder.typicode.com/')
    .then((result) => response.text(), 
    .catch((error) => { console.log(error); })
    .then((result) => { console.log(result); });


# catch 메소드를 마지막에 사용
fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => response.json())
    .then((result) => { console.log(result); })
    .catch((error) => { console.log(error); });



# 어디서 발생한 에러인지 확인해보기

    .catch((error) => { 
        if(error.message === 'A'){

        }else if(error.message === 'B'){

        }else if(error.message === 'C'){

        }else{

        }
    });


====
.catch((error) => { 
    if(error instanceof TypeError){

    }else if(error instanceof CustomErrorType_A){

    }else if(error instanceof CustomErrorType_B){

    }else{

    }
});

# catch 메소드를 여러 개 쓰는 경우

우리는 이제 catch 메소드를 Promise Chain 가장 마지막에 붙임으로써, 중간에 에러가 발생해서 어느 Promise 객체가 rejected 상태가 되더라도 항상 대처할 수 있도록 해야 한다는 걸 배웠습니다. 하지만 catch 메소드를 마지막뿐만 아니라 Promise Chain 중간중간에 쓰는 경우도 존재합니다. 만약 중간에 에러가 발생해도 catch 메소드가 그 대안을 뒤로 넘겨줄 수 있으면 catch 메소드를 중간에 써도 되는데요.

아래 코드를 잠깐 봅시다.

fetch('https://friendbook.com/my/newsfeeds')
  .then((response) => response.json()) // -- A
  .then((result) => { // -- B
    const feeds = result;
    // 피드 데이터 가공...
    return processedFeeds; 
  })
  .catch((error) => { // -- C
    // 미리 저장해둔 일반 뉴스를 보여주기  
    const storedGeneralNews = getStoredGeneralNews();
    return storedGeneralNews;
  })
  .then((result) => { /* 화면에 표시 */ }) // -- D
  .catch((error) => { /* 에러 로깅 */ }); // -- E
이 코드는 어떤 SNS 웹 사이트에서 나에게 최적화된 뉴스피드(newsfeed)를 보여주는 코드라고 가정해봅시다. 만약 서버로부터 뉴스피드가 잘 조회되면 현재 코드에서 A, B, D 줄에 있는 콜백들이 잘 실행되고, 사용자에게 뉴스피드가 잘 표시되겠죠? 하지만 만약 사용자의 컴퓨터가 인터넷에 연결되어 있지 않은 상태라서 fetch 함수의 작업이 실패한다면 어떻게 될까요? 그럼 이제 이 Promise Chain의 작업은 실패했다고 생각하고, 이전에 배운 것처럼 그냥 마지막에만 catch 메소드를 두고 끝내면 되는 걸까요? 꼭 그렇지는 않습니다. 만약 작업을 살릴 수 있는 방법이 있다면 살리는 게 좋겠죠?

지금 C줄에 있는 콜백을 보세요. fetch 함수의 작업이 실패하면 C 줄의 콜백이 실행됩니다. 사실, 이 SNS 서비스의 웹 페이지에서는 사용자가 매번 뉴스피드를 볼 때마다, 나중에 오프라인 상태가 될 때를 대비해서 모든 사람이 공통으로 볼 수 있는, 텍스트로만 이루어진 최근 일반 뉴스 데이터를 갱신해서 웹 브라우저에 저장한다고 해봅시다. C줄의 콜백은 바로 이렇게 저장해둔 일반 뉴스 데이터를 그대로 가져오는 기능을 합니다. 이렇게 되면 인터넷이 안 되는 상황에서도 나만을 위한 최적화된 뉴스피드는 못 보지만 일반적인 세상 뉴스는 사용자가 볼 수 있게 되겠죠?

이렇게 Promise Chain 중에서 비록 에러가 발생했다고 해도 만약 실패한 작업 대신 다른 방법을 통해서 작업을 정상적으로 끝마칠 수 있는 상황이라면 catch 메소드를 중간에 사용하기도 합니다. 그러니까 Promise Chain 중에서 단 하나의 작업이라도 실패하면 전체 작업이 실패했다고 봐도 되는 경우에는 그냥 Promise Chain 마지막에만 catch 메소드를 써주면 되겠지만, 어떤 작업들은 에러가 발생하더라도 다른 방식으로 복구해서 살려낼 방법이 있다면 catch 메소드 안의 콜백에서 그런 복구 작업을 해주면 되는 겁니다. 지금 위 코드에서는 미리 저장해둔 일반 뉴스 데이터를 구해오는 getStoredGeneralNews 함수를 실행하는 것처럼요.

catch 메소드를 Promise Chain의 마지막에 늘 써줘야 하는 것은 맞지만, 작업을 살릴 방법이 있다면 Promise Chain 중간에 catch 메소드를 써도 된다는 사실, 잘 기억해두세요.



# finally 메소드
// catch 메소드 이후에 사용한다.

fetch('https://jsonplaceholder.typicode.com/users')
    .then((response) => response.text())
    .then((result) => { console.log(result); })
    .catch((error) => { console.log(error); });
    .finally(() => { console.log('exit'); });

// catch method가 return한 Promise 객체를 rejected 함.
.catch((error) => {
    console.log(error); 
    throw new Error('from catch method');
});


#실습 설명

Promise Chain에서 늘 모든 작업이 정상적으로 수행되고 종료되는 것은 아닙니다. 모든 작업이 순차적으로 정상 수행되는 경우도 있고 중간에 문제가 생겨서 그렇지 못하는 경우도 있어요. 이 두 가지 중 어느 경우가 됐든 마지막에 항상 처리해 줘야하는 작업이 있을 때는 finally 메소드를 사용합니다.

지금 코드잇 실행기에는 어떤 웹 페이지의 로딩(loading) 아이콘에 관한 코드가 있습니다. 이 코드에서는 어떤 URL로 리퀘스트를 보내기 전에 isLoading이라는 변수의 값을 true로 설정하고, 로딩 아이콘을 띄운 후에 리퀘스트를 보내는데요.

첫 번째 then 메소드의 콜백을 보면, 리스폰스의 헤드에서 'content-type' 헤더를 찾아 그 값을 읽고 만약 'application/json'이라는 값을 포함하고 있다면 즉, 리스폰스의 바디에 JSON 포맷의 데이터가 들어있다면 이를 Deserialize해서 다음으로 넘깁니다. 하지만 'application/json' 타입이 아니라면 인위적으로 에러를 발생시킵니다.

그런데 어떤 경우든 상관없이 모든 작업이 끝나고 나면, isLoading 변수의 값은 false로 설정해 줘야 합니다. 
왜냐하면 이 isLoading 변수는 현재 사용자의 리퀘스트에 대한 처리가 이루어지고 있고, 로딩 아이콘이 화면에서 나타나있는지 여부를 나타냄으로써, 더 이상 사용자가 마우스를 아무리 클릭해도 리퀘스트를 또 보내는 것을 막고, 그 밖의 다른 작업이 시작되지 못하도록 막아야하는지를 판단하기 위한 기준으로 사용되기 때문입니다. (실무에서는 이런 변수를 사용하는 것 말고 다른 좋은 방법들도 있지만 일단은 간단한 코드로 배워 봅시다.)

어떤 경우든 마지막에 isLoading 변수의 값이 false가 되어야, 이 웹 페이지는 전체 작업의 성공 여부와 상관없이 앞으로도 정상적으로 동작할 수 있는데요. 필요한 코드를 추가해서 어떤 경우든 isLoading 변수의 값을 false로 만들고 그 값을 출력해 보세요.

참고로, 코드 상단의 URL 두 개 중에서 첫 번째는 JSON 데이터가 오는 URL이고, 두 번째는 HTML 등의 코드가 오는 URL입니다.

각 URL 앞의 주석을 번갈아 해제해서 코드를 실행해보고 isLoading 변수가 항상 false가 되는지 확인해 보세요.

let isLoading = true;

/* ..다른 코드들 */

const url = 'https://jsonplaceholder.typicode.com/users';
// const url = 'https://www.google.com';

fetch(url)
  .then((response) => {
    const contentType = response.headers.get('content-type');
    if (contentType.includes('application/json')) {
      return response.json();
    }
    throw new Error('response is not json data');
  })
  .then((result) => {
    // 리스폰스 처리
    console.log(result);
  })
  .catch((error) => {
    // 에러 처리
    console.log(error);
  })
  .finally(() => {
    isLoading = false;
    console.log(isLoading);
  });

/* ..다른 코드들 */


# 변수와 스코프

var x;  //함수 스코프 (function scope)
let y;  //블록 스코프 (block scope)
const z;  //블록 스코프 (block scope)

# 종합 정리
자바스크립트의 데이터 타입
자바스크립트에는 8가지 데이터 타입이 있습니다.

number
string
boolean
undefined
null
object
symbol
bigint
자바스크립트의 유연한 데이터 타입
자바스크립트는 데이터 타입이 유연한 프로그래밍 언어입니다. 맥락에 유연하게 변하는 데이터 타입의 특징은 처음엔 생소하고 혼란스러울 수 있지만, 잘 이해하고 활용한다면 좀 더 간결한 코드를 작성하고 빠르게 개발할 수 있는 장점이 될 수 있습니다!

Truthy 값과 Falsy 값
if, for, while 등 불린 타입의 값이 요구되는 맥락에서는 조건식이나 불린 타입의 값 뿐만아니라 다른 타입의 값도 불린 값처럼 평가될 수 있는데요. 이 때, false 처럼 평가되는 값을 falsy 값, true 처럼 평가되는 값을 truthy값이라고 부릅니다. falsy값에는 false, null, undefined, 0, NaN, ''(빈 문자열)이 있고, falsy값을 제외한 값들은 모두 truthy값이 됩니다.

만약 falsy와 truthy값을 명확하게 확인하고 싶다면 Boolean 함수를 사용해서 직접 boolean 타입으로 형 변환 해볼 수도 있습니다.

// falsy
Boolean(false);
Boolean(null);
Boolean(undefined);
Boolean(0);
Boolean(NaN);
Boolean('');

// truthy
Boolean(true);
Boolean('codeit');
Boolean(123);
Boolean(-123);
Boolean({});
Boolean([]);
truthy와 falsy의 개념은 자바스크립트에서 불린 타입으로의 형 변환을 이해할 때 핵심이되는 개념이 잘 기억해 주세요.

독특한 방식으로 동작하는 논리 연산자
자바스크립트에서 AND와 OR연산자는 무조건 불린 값을 리턴하는게 아니라, 왼쪽 피연산자 값의 유형에 따라서 두 피연산자 중 하나를 리턴하는 방식으로 동작합니다.
AND 연산자는 왼쪽 피연산자가 falsy값일 때 왼쪽 피연산자를, 왼쪽 피연산자가 truthy값일 때 오른쪽 피연산자를 리턴하고 반대로, OR 연산자는 왼쪽 피연산자가 falsy 일 때 오른쪽 피연산자를, 왼쪽 피연산자가 truthy 일 때 왼쪽 피연산자를 리턴합니다.

console.log(null && undefined); // null
console.log(0 || true); // true
console.log('0' && NaN); // NaN
console.log({} || 123); // {}
자바스크립트의 다양한 변수 선언 방식
자바스크립트에는 다양한 변수 선언 키워드가 있습니다. 자바스크립트가 처음 등장할 때부터 사용되던 var와, 그리고 var의 부족함을 채우기위해 ES2015에서 새롭게 등장한 let과 const가 있는데요.

var 변수는 아래와 같은 특징이 있었습니다.

변수 이름 중복선언 가능,
변수 선언 전에 사용 가능(호이스팅),
함수 스코프
특히나 중복된 이름으로 선언이 가능했던 특징은 여러 사람이 협업할 때 생각보다 자주 문제가 되곤 했었는데요. 
이런 문제를 개선하기 위해 ES2015에서 let과 const가 등장했고, 다음과 같은 특징이 있습니다.

변수 이름 중복선언 불가 (SyntaxError 발생)
변수 선언 전에 사용 불가 (ReferenceError 발생)
블록 스코프
덧붙여 const 키워드는 let 키워드와 다르게 값을 재할당할 수 없다는 특징도 있습니다.
그래서 ES2015 이후부터는 var보다 let과 const 키워드 사용이 권장된다는 사실도 참고해 두시면 좋을 것 같습니다.

함수 스코프(function scope)와 블록 스코프(block scope)
var 키워드로 선언한 변수는 함수 스코프 let과 const 키워드로 선언한 변수는 블록 스코프를 가집니다.

함수 스코프란 말 그대로 함수를 기준으로 스코프를 구분한다는 뜻인데요. 그렇기 때문에 아래 코드처럼 함수 안에서 선언한 변수는 함수 안에서만 유효하게 됩니다.

function sayHi() {
  var userName = 'codeit';
  console.log(`Hi ${userName}!`);
}

console.log(userName); // ReferenceError
하지만 함수를 제외한 for, if, while 등과 같은 문법 안에서 선언한 변수는 그 문법 밖에서도 계속 유효했었기 때문에 때로는 중복선언등의 문제가 생겨나기도 했는데요.
이런 문제를 해결하기 위해 let과 const 키워드와 함께 블록 스코프가 등장하게 된 겁니다.

for (var i = 0; i < 5; i++) {
  console.log(i);
}

console.log(i); // 5
블록 스코프는 중괄호로 감싸진 코드 블록에 따라 유효 범위를 구분하게 되는데요. 아래 코드에서 볼 수 있듯이 함수와 다른 문법들 뿐만아니라, 그냥 중괄호로 감싸진 코드 블록으로도 유효 범위가 구분되는 모습을 확인할 수 있습니다.

function sayHi() {
  const userName = 'codeit';
  console.log(`Hi ${userName}!`);
}

for (let i = 0; i < 5; i++) {
  console.log(i);
}

{
  let language = 'JavaScript';
}

console.log(userName); // ReferenceError
console.log(i); // ReferenceError
console.log(language); // ReferenceError

# 함수를 만드는 방법
function 함수이름(파라미터) {
    동작;
    return 리턴값;
}
함수 호출;

# 함수를 변수에 할당 하는 방법
const printCodeit = function () {
    console.log('Codeit');
};

printCodeit();


// 함수에 할당하는 방법은 호이스팅이 불가하다. 에러발생

printCodeit();

const printCodeit = function () {
    console.log('Codeit');
};


# 함수호출을 위쪽으로 끌어 올리는 방법을 호이스팅(Hoisting)

printCodeit();

function printCodeit() {
    console.log('Codeit');
};



# 이름이 있는 함수 표현식
Named Function Expression (기명 함수 표현식)
함수 표현식으로 함수를 만들 때는 선언하는 함수에 이름을 붙여줄 수도 있는데요.
이름이 있는 함수 표현식, 즉 기명 함수 표현식이라고 부릅니다.
함수 표현식으로 함수가 할당된 변수에는 자동으로 name이라는 프로퍼티를 가지게 되는데요.

const sayHi = function () {
  console.log('Hi');
};

console.log(sayHi.name); // sayHi
이렇게 이름이 없는 함수를 변수에 할당할 때는 변수의 name 프로퍼티는 변수 이름 그 자체를 문자열로 가지게 됩니다. 하지만 함수에 이름을 붙여주게 되면, name 속성은 함수 이름을 문자열로 갖게 되는데요.

const sayHi = function printHiInConsole() {
  console.log('Hi');
};

console.log(sayHi.name); // printHiInConsole
이 함수 이름은 함수 내부에서 함수 자체를 가리킬 때 사용할 수 있고 함수를 외부에서 함수를 호출할 때 사용할 수는 없습니다.

const sayHi = function printHiInConsole() {
  console.log('Hi');
};

printHiInConsole(); // ReferenceError
기명 함수 표현식은 일반적으로 함수 내부에서 함수 자체를 가리킬 때 사용되는데요. 아래 코드를 살펴봅시다.

let countdown = function(n) {
  console.log(n);

  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

countdown(5);
아규먼트로 숫자 값을 전달하고 전달받은 그 값이 0이 될 때까지 하나씩 값을 줄이면서 자기 자신을 호출하는 countdown이라는 함수를 함수 표현식으로 작성해봤는데요. 이런 식으로 자기 자신을 부르는 함수를 재귀 함수(Recursive function)라고 부릅니다.
그런데 만약 이 함수를 복사하려고 다른 변수에 똑같이 담았다가, countdown 변수에 담긴 값이 변하게 되면 문제가 발생하는데요.

let countdown = function(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
};

let myFunction = countdown;

countdown = null;

myFunction(5); // TypeError
에러코드실행화면

마지막 줄에서 myFunction 함수를 호출했을 때, 함수가 실행되긴 하지만, 6번줄 동작을 수행할 때 호출하려는 countdown 함수가 이미 12번에서 null 값으로 변경되었기 때문에 함수가 아니라는 TypeError가 발생한 것이죠!
이런 상황을 방지하기 위해서 함수 내부에서 함수 자신을 사용하려고 하면 함수표현식에서는 반드시 기명 함수 표현식을 사용하는 것이 좋습니다.

let countdown = function printCountdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    printCountdown(n - 1);
  }
};

let myFunction = countdown;

countdown = null;

myFunction(5); // 정상적으로 동작
정상코드실행화면

함수 표현식을 작성할 때, 함수에 이름을 지정할 수 있다는 점과 특히 이렇게 함수 내에서 함수를 가리켜야 할 때는 꼭 함수 이름을 작성해주는 것이 안전하다는 점. 잘 기억해 두시면 좋을 것 같습니다.



# 즉시 실행 함수 (IIFE)

지금까지 함수를 선언하는 다양한 방법에 대해 살펴봤는데요.
함수를 선언하는 것은 함수를 실행하는 것과 다르다는 사실, 모두 알고 계시죠?

function sayHi() {
  console.log('Hi!');
}
  
sayHi();
일반적으로는 이렇게 함수를 먼저 선언한 다음,선언된 함수 이름 뒤에 소괄호를 붙여서 함수를 실행하는데요.
그런데 때로는 함수가 선언된 순간에 바로 실행을 할 수도 있습니다.

즉시 실행 함수
(function () {
  console.log('Hi!');
})();
보시는 것처럼 함수선언 부분을 소괄호로 감싼 다음에 바로 뒤에 함수를 실행하는 소괄호를 한 번 더 붙여주는 방식인데요.
이렇게 하면 함수가 선언된 순간 바로 실행이 되는 겁니다.

이렇게 함수 선언과 동시에 즉시 실행되는 함수를 가리켜 즉시 실행 함수 (표현)이라고 부르는데요.
영어로는 Immediately Invoked Function Expression, 줄여서 IIFE라고 부릅니다.

(function (x, y) {
  console.log(x + y);
})(3, 5);
그리고 즉시 실행 함수도 일반 함수처럼 파라미터를 작성하고, 함수를 호출할 때 아규먼트를 전달할 수도 있는데요.
한 가지 주의할 점은 즉시 실행 함수는 함수에 이름을 지어주더라도 외부에서 재사용할 수 없다는 겁니다.

(function sayHi() {
  console.log('Hi!');
})();

sayHi(); // ReferenceError
그래서 일반적으로는 이름이 없는 익명 함수를 사용하는데요.
다만, 이름이 있는 함수 표현식 레슨에서도 살펴봤던 것처럼 함수 내부에서 자기 자신을 호출하는 재귀적인 구조를 만들고자 할 땐 이름이 필요할 수도 있으니까 이 부분은 참고해 주세요!

(function countdown(n) {
  console.log(n);
  if (n === 0) {
    console.log('End!');
  } else {
    countdown(n - 1);
  }
})(5);
즉시 실행 함수의 활용
즉시 실행 함수는 말 그대로 선언과 동시에 실행이 이뤄지기 때문에 일반적으로 프로그램 초기화 기능에 많이 활용됩니다.

(function init() {
  // 프로그램이 실행 될 때 기본적으로 동작할 코드들..
})();
혹은 재사용이 필요 없는, 일회성 동작을 구성할 때 활용하기도 하는데요.

const firstName = 'Young';
const lastName = 'Kang';

const greetingMessage = (function () {
  const fullName = `${firstName} ${lastName} `;

  return `Hi! My name is ${fullName}`;
})();
이렇게 함수의 리턴값을 바로 변수에 할당하고 싶을 때 활용할 수 있습니다.

그리고, 전역변수와 지역변수의 개념 알고 계시죠?
즉시 실행 함수에서 사용하는 변수들은 함수 내에서만 유효하기 때문에 이런 점을 활용하면, 일시적으로 사용할 변수의 이름들을 조금 자유롭게 작성할 수도 있다는 점. 잘 기억해 두세요!

# 고차 함수 (Higher Order Function)
function getPrintHi() {
    return function () {
        console.log('Hi!?');
    };
};
const sayHi = getPrintHi();

sayHi();

=== 바로 호출도 가능
getPrintHi()();

// = 일급 함수(First Class Function)


# Parameter

function greeting(name) {
    console.log('Hi! My name is ${name}!');
}

greeting('JavaScript');


# 아규먼트(argument)

function greeting(파라미터) {
    console.log('Hi! My name is ${name}!');
}

greeting('아규먼트');

// 파라미터가 있는 함수를 호출할 때 빈 아규먼트를 호출하게 되면 undefined를 호출한다.
greeting(); 

# 파라미터 값을 지정하면 파라미터 값을 호출한다.

function greeting(name = 'Codeit') {
    console.log('Hi! My name is ${name}!');
}
greeting();
// Hi! My name is Codeit!

# 파라미터 값을 지정하게 되면 우측 마지막에 작성을 한다. 그렇지 않으면 undefined가 호출됨.
# function greeting(interest, name = 'Codeit')
function greeting(name = 'Codeit', interest) {
    console.log('Hi! My name is ${name}!');
    console.log('I like ${interest}!');
}
greeting();
// Hi! My name is Codeit!
// I like undefined!



function greeting(interest, name = 'Codeit') {
    console.log('Hi! My name is ${name}!');
    console.log('I like ${interest}!');
}

greeting('Java');


# Arguments
// 함수에 for문을 이용해서 아규먼트를 불러 올수 있다.
# 변수로 argument 사용을 해서는 안된다.
function printArguments(a, b, c) {
    for (const arg of arguments) {
        console.log(arg);
    }
    console.log{'--------------'};
}

printArguments('tony', 'Mark', 'Koby');
printArguments('Captain');
printArguments('suri', 'kack', 'joy', 'noel');



# 실습 설명
겉바속촉(겉은 바삭하고 속은 촉촉한), 아바라(아이스 바닐라 라떼), 얼죽아(얼어 죽어도 아이스), 별다줄 (별걸 다 줄인다) 등 우리 일상생활에 여러 단어가 조합된 단어를 앞 글자만 따서 다시 한번 더 줄여쓴 줄임말들이 넘쳐나고 있는데요.
arguments 객체를 활용해서 함수를 호출할 때 전달하는 단어들의 첫 글자만 따서 줄임말을 만들어주는 firstWords 함수를 완성해 주세요.

실습 결과
코드를 잘 작성하셨다면 아래와 같은 결과가 출력되어야 합니다.

나없고
아바라
만반잘부
결자해지
빨주노초파남보

# 작성
function firstWords() {
  let word = '';

  for(const arg of arguments) {
    word += arg[0];
  }

  console.log(word);
}

firstWords('나만', '없어', '고양이');
firstWords('아니', '바나나말고', '라면먹어');
firstWords('만두', '반으로', '잘라먹네', '부지런하다');
firstWords('결국', '자바스크립트가', '해피한', '지름길');
firstWords('빨간색', '주황색', '노란색', '초록색', '파란색', '남색', '보라색');



# 태그 이름으로 태그 선택하기

지금까지 id와 class 속성을 이용해서 JavaScript로 HTML 태그를 선택하는 방법에 대해 알아봤는데요.
document.getElementsByTagName('태그이름')메소드를 활용하면 태그 이름으로 태그를 선택할 수 있습니다.

const btns = document.getElementsByTagName('button');

이렇게 하면 HTML 문서 내에 있는 모든 button 태그를 선택하게 됩니다.

태그이름으로태그선택하기

document.getElementsByClassName('class')메소드와 마찬가지로 태그 이름으로 요소를 찾는 경우에 여러 개의 요소가 선택될 수 있기 때문에 메소드 이름에 Element(s), s가 있고, 실행결과 역시 HTMLCollection을 리턴한다는 점도 함께 기억해 두시면 좋을 것 같습니다.

참고로 css 선택자처럼 '*' 값을 전달하게 되면 모든 태그를 선택할 수도 있는데요.

const btns = document.getElementsByTagName('button');
const allTags = document.getElementsByTagName('*');
하지만, css 스타일링을 할 때도 태그 이름으로 스타일링을 하는 경우는 거의 없죠?

마찬가지로 명확한 의도가 없이 이렇게 많은 요소들을 한꺼번에 다루게 되면 예상치 못한 실수를 할 가능성이 있기 때문에 자바스크립트에서도 많이 사용되는 메소드는 아닙니다.


